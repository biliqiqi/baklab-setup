package services

import (
	"crypto/rand"
	"encoding/hex"
	"fmt"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"text/template"
	"time"

	"github.com/biliqiqi/baklab-setup/internal/model"
)

// GeneratorService 配置文件生成服务
type GeneratorService struct {
	outputDir string
}

// NewGeneratorService 创建生成器服务实例
func NewGeneratorService() *GeneratorService {
	return &GeneratorService{
		outputDir: "./output", // 输出到setup目录下的output子目录
	}
}

// SetOutputDir 设置输出目录
func (g *GeneratorService) SetOutputDir(dir string) {
	g.outputDir = dir
}

// ClearOutputDir 清空输出目录
func (g *GeneratorService) ClearOutputDir() error {
	// 检查目录是否存在
	if _, err := os.Stat(g.outputDir); os.IsNotExist(err) {
		// 目录不存在，无需清理
		return nil
	}

	// 遍历输出目录，跳过特定目录
	entries, err := os.ReadDir(g.outputDir)
	if err != nil {
		return fmt.Errorf("failed to read output directory: %w", err)
	}

	for _, entry := range entries {
		entryPath := filepath.Join(g.outputDir, entry.Name())

		// 跳过 nginx/logs 目录以避免权限问题
		if entry.Name() == "nginx" {
			// 处理 nginx 目录：保留 logs 子目录，删除其他内容
			if err := g.clearNginxDir(entryPath); err != nil {
				return fmt.Errorf("failed to clear nginx directory: %w", err)
			}
			continue
		}

		// 删除其他文件和目录
		if err := os.RemoveAll(entryPath); err != nil {
			return fmt.Errorf("failed to remove %s: %w", entryPath, err)
		}
	}

	return nil
}

// clearNginxDir 清理 nginx 目录但保留 logs 子目录
func (g *GeneratorService) clearNginxDir(nginxPath string) error {
	entries, err := os.ReadDir(nginxPath)
	if err != nil {
		// 如果 nginx 目录不存在，直接返回
		if os.IsNotExist(err) {
			return nil
		}
		return err
	}

	for _, entry := range entries {
		entryPath := filepath.Join(nginxPath, entry.Name())

		// 跳过 logs 目录
		if entry.Name() == "logs" {
			log.Printf("Skipping nginx/logs directory to avoid permission issues")
			continue
		}

		// 删除其他文件和目录
		if err := os.RemoveAll(entryPath); err != nil {
			return fmt.Errorf("failed to remove %s: %w", entryPath, err)
		}
	}

	return nil
}

// GenerateEnvFile 生成.env文件
func (g *GeneratorService) GenerateEnvFile(cfg *model.SetupConfig) error {
	// 确保输出目录和子目录存在
	if err := os.MkdirAll(g.outputDir, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	// 创建必要的子目录
	certsDir := filepath.Join(g.outputDir, "certs")
	if err := os.MkdirAll(certsDir, 0755); err != nil {
		return fmt.Errorf("failed to create certs directory: %w", err)
	}

	dataDir := filepath.Join("./data")
	if err := os.MkdirAll(dataDir, 0755); err != nil {
		return fmt.Errorf("failed to create data directory: %w", err)
	}

	logsDir := filepath.Join("./data/logs")
	if err := os.MkdirAll(logsDir, 0755); err != nil {
		return fmt.Errorf("failed to create logs directory: %w", err)
	}

	// 生成缺失的密钥
	if cfg.App.SessionSecret == "" {
		cfg.App.SessionSecret = g.generateSecretKey(64)
	}
	if cfg.App.CSRFSecret == "" {
		cfg.App.CSRFSecret = g.generateSecretKey(64)
	}

	// 环境配置模板
	envTemplate := `# Generated by baklab setup service
# Generated at: {{ .Timestamp }}

# Language Configuration
DEFAULT_LANG={{ .App.DefaultLang }}

# Database Configuration
DB_HOST='{{ .Database.Host }}'
DB_PORT={{ .Database.Port }}
PG_USER='{{ .Database.User }}'
PG_PASSWORD='{{ .Database.Password }}'
APP_DB_NAME='{{ .Database.Name }}'
APP_DB_USER='{{ .Database.User }}'
APP_DB_PASSWORD='{{ .Database.Password }}'

# Redis Configuration
REDIS_HOST='{{ .Redis.Host }}'
REDIS_PORT={{ .Redis.Port }}
REDIS_USER='{{ if .Redis.User }}{{ .Redis.User }}{{ else }}user{{ end }}'
REDIS_PASSWORD='{{ .Redis.Password }}'
REDISCLI_AUTH='{{ .Redis.Password }}'

# Application Configuration
DOMAIN_NAME='{{ .App.DomainName }}'
BASE_DOMAIN_NAME='{{ .App.DomainName }}'
BRAND_NAME='{{ .App.BrandName }}'
BRAND_DOMAIN_NAME='{{ .App.DomainName }}'
ADMIN_EMAIL='{{ .App.AdminEmail }}'
ADMIN_PASSWORD='{{ .Database.Password }}'
DEBUG={{ .App.Debug }}
TEST=false
APP_VERSION={{ if .App.Version }}{{ .App.Version }}{{ else }}latest{{ end }}

# Security Configuration
SESSION_SECRET='{{ .App.SessionSecret }}'
CSRF_SECRET='{{ .App.CSRFSecret }}'
JWT_KEY_FILE=./keys/jwt-private.pem

# Application Ports
APP_PORT=3000
APP_OUTER_PORT=3000
FRONTEND_PORT=5173
NGINX_PORT=80
NGINX_SSL_PORT=443

# Network Configuration
{{ if .CORSOrigins }}CORS_ALLOW_ORIGINS='{{ .CORSOrigins }}'{{ else }}CORS_ALLOW_ORIGINS='http{{ if ne .App.DomainName "localhost" }}s{{ end }}://{{ .App.DomainName }}'{{ end }}

# Frontend Configuration
FRONTEND_ROOT_ID=root
FRONTEND_SCRIPTS=
FRONTEND_STYLES=

# Service Configuration
SERVICE_URL='http{{ if ne .App.DomainName "localhost" }}s{{ end }}://{{ .App.DomainName }}{{ if eq .App.DomainName "localhost" }}:3000{{ end }}'
STATIC_HOST_NAME='{{ .App.DomainName }}{{ if eq .App.DomainName "localhost" }}:8787{{ end }}'

# OAuth Configuration (optional)
{{ if .App.GoogleClientID }}GOOGLE_CLIENT_ID='{{ .App.GoogleClientID }}'{{ else }}GOOGLE_CLIENT_ID={{ end }}
{{ if .App.GoogleSecret }}GOOGLE_CLIENT_SECRET='{{ .App.GoogleSecret }}'{{ else }}GOOGLE_CLIENT_SECRET={{ end }}
{{ if .App.GithubClientID }}GITHUB_CLIENT_ID='{{ .App.GithubClientID }}'{{ else }}GITHUB_CLIENT_ID={{ end }}
{{ if .App.GithubSecret }}GITHUB_CLIENT_SECRET='{{ .App.GithubSecret }}'{{ else }}GITHUB_CLIENT_SECRET={{ end }}

# Cloudflare Configuration (optional)
{{ if .App.CloudflareSiteKey }}CLOUDFLARE_SITE_KEY='{{ .App.CloudflareSiteKey }}'{{ else }}CLOUDFLARE_SITE_KEY={{ end }}
{{ if .App.CloudflareSecret }}CLOUDFLARE_SECRET='{{ .App.CloudflareSecret }}'{{ else }}CLOUDFLARE_SECRET={{ end }}

# SMTP Configuration (optional)
{{ if .SMTP.Server }}SMTP_SERVER='{{ .SMTP.Server }}'{{ else }}SMTP_SERVER={{ end }}
SMTP_SERVER_PORT={{ if .SMTP.Port }}{{ .SMTP.Port }}{{ else }}587{{ end }}
{{ if .SMTP.User }}SMTP_USER='{{ .SMTP.User }}'{{ else }}SMTP_USER={{ end }}
{{ if .SMTP.Password }}SMTP_PASSWORD='{{ .SMTP.Password }}'{{ else }}SMTP_PASSWORD={{ end }}
{{ if .SMTP.Sender }}SMTP_SENDER='{{ .SMTP.Sender }}'{{ else }}SMTP_SENDER='noreply@{{ .App.DomainName }}'{{ end }}

# File Paths
GEOIP_ENABLED=false
GEOIP_FILE=./geoip/Country.mmdb
I18N_FILE_DIR=./i18n
MIGRATION_FILE_DIR=./config/db/migrations
DEFAULT_DATA_DIR=./config/defaults

# Development Configuration
HOST_PROXY=http://127.0.0.1:1008
APP_LOCAL_HOST=172.17.0.1

# TLS Configuration (uncomment to enable)
# APP_AUTOCERT=1
# APP_TLS_CERT=./certs/server.crt
# APP_TLS_KEY=./certs/server.key

# Version
APP_VERSION={{ if .App.Version }}{{ .App.Version }}{{ else }}latest{{ end }}

# Setup Status
SETUP_COMPLETED=true
SETUP_COMPLETED_AT={{ .Timestamp }}
`

	// 解析模板
	tmpl, err := template.New("env").Parse(envTemplate)
	if err != nil {
		return fmt.Errorf("failed to parse env template: %w", err)
	}

	// 准备CORS配置字符串
	corsOrigins := ""
	if len(cfg.App.CORSAllowOrigins) > 0 {
		corsOrigins = strings.Join(cfg.App.CORSAllowOrigins, ",")
	}

	// 准备模板数据
	data := struct {
		*model.SetupConfig
		Timestamp   string
		CORSOrigins string
	}{
		SetupConfig: cfg,
		Timestamp:   time.Now().Format(time.RFC3339),
		CORSOrigins: corsOrigins,
	}

	// 创建输出文件
	filePath := filepath.Join(g.outputDir, ".env.production")
	file, err := os.Create(filePath)
	if err != nil {
		return fmt.Errorf("failed to create env file: %w", err)
	}
	defer func() {
		if err := file.Close(); err != nil {
			log.Printf("Warning: failed to close env file: %v", err)
		}
	}()

	// 执行模板
	if err := tmpl.Execute(file, data); err != nil {
		return fmt.Errorf("failed to execute env template: %w", err)
	}

	return nil
}

// GenerateDockerConfig 生成Docker配置文件
func (g *GeneratorService) GenerateDockerConfig(cfg *model.SetupConfig) error {
	// 首先复制必要的模板文件到config目录
	if err := g.copyTemplateFiles(cfg); err != nil {
		return fmt.Errorf("failed to copy template files: %w", err)
	}
	dockerComposeTemplate := `# Generated by baklab setup service
# Production Docker Compose Configuration

services:
  webapp:
    image: ghcr.io/biliqiqi/baklab:$APP_VERSION
    container_name: "webapp-app-1"
    restart: always
    environment:
      {{- if eq .Database.ServiceType "docker" }}
      DB_CONTAINER_NAME: "local-webapp-db"
      DB_HOST: "db"
      DB_PORT: 5432
      {{- else }}
      DB_HOST: "{{.Database.Host}}"
      DB_PORT: {{.Database.Port}}
      {{- end }}
      DOMAIN_NAME: $DOMAIN_NAME
      APP_DB_NAME: $APP_DB_NAME
      APP_DB_USER: $APP_DB_USER
      APP_DB_PASSWORD: $APP_DB_PASSWORD
      ADMIN_EMAIL: $ADMIN_EMAIL
      APP_PORT: $APP_PORT
      APP_OUTER_PORT: $APP_OUTER_PORT
      NGINX_PORT: $NGINX_PORT
      NGINX_SSL_PORT: $NGINX_SSL_PORT
      SESSION_SECRET: $SESSION_SECRET
      CSRF_SECRET: $CSRF_SECRET
      {{- if eq .Redis.ServiceType "docker" }}
      REDIS_HOST: "redis"
      REDIS_PORT: 6379
      {{- else }}
      REDIS_HOST: "{{.Redis.Host}}"
      REDIS_PORT: {{.Redis.Port}}
      {{- end }}
      REDIS_USER: $REDIS_USER
      REDIS_PASSWORD: $REDIS_PASSWORD
      REDISCLI_AUTH: $REDISCLI_AUTH
      SMTP_SERVER: $SMTP_SERVER
      SMTP_SERVER_PORT: $SMTP_SERVER_PORT
      SMTP_USER: $SMTP_USER
      SMTP_PASSWORD: $SMTP_PASSWORD
      SMTP_SENDER: $SMTP_SENDER
      GOOGLE_CLIENT_ID: $GOOGLE_CLIENT_ID
      GOOGLE_CLIENT_SECRET: $GOOGLE_CLIENT_SECRET
      GITHUB_CLIENT_ID: $GITHUB_CLIENT_ID
      GITHUB_CLIENT_SECRET: $GITHUB_CLIENT_SECRET
      APP_VERSION: $APP_VERSION
      CLOUDFLARE_SITE_KEY: $CLOUDFLARE_SITE_KEY
      CLOUDFLARE_SECRET: $CLOUDFLARE_SECRET
      JWT_KEY_FILE: $JWT_KEY_FILE
      SERVICE_URL: $SERVICE_URL
      STATIC_HOST_NAME: $STATIC_HOST_NAME
      CORS_ALLOW_ORIGINS: $CORS_ALLOW_ORIGINS
      FRONTEND_ROOT_ID: $FRONTEND_ROOT_ID
      FRONTEND_SCRIPTS: $FRONTEND_SCRIPTS
      FRONTEND_STYLES: $FRONTEND_STYLES
      GEOIP_ENABLED: $GEOIP_ENABLED
      GEOIP_FILE: $GEOIP_FILE
      I18N_FILE_DIR: $I18N_FILE_DIR
      MIGRATION_FILE_DIR: $MIGRATION_FILE_DIR
      DEFAULT_DATA_DIR: $DEFAULT_DATA_DIR
      DEFAULT_LANG: $DEFAULT_LANG
      BRAND_NAME: $BRAND_NAME
      BRAND_DOMAIN_NAME: $BRAND_DOMAIN_NAME
      DEBUG: $DEBUG
      TEST: $TEST
    volumes:
      - ./manage_static:/app/manage_static
      {{ if .App.HasJWTKeyFile -}}
      - ./keys:/app/keys
      {{- else -}}
      - {{ .App.JWTKeyFilePath }}:/app/keys/jwt-private.pem
      {{- end }}
    {{- if or (eq .Database.ServiceType "docker") (eq .Redis.ServiceType "docker") }}
    depends_on:
      {{- if eq .Database.ServiceType "docker" }}
      db:
        condition: service_healthy
      {{- end }}
      {{- if eq .Redis.ServiceType "docker" }}
      redis:
        condition: service_healthy
      {{- end }}
    {{- end }}
    {{- if or (eq .Database.ServiceType "docker") (eq .Redis.ServiceType "docker") }}
    links:
      {{- if eq .Database.ServiceType "docker" }}
      - db
      {{- end }}
      {{- if eq .Redis.ServiceType "docker" }}
      - redis
      {{- end }}
    {{- end }}
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:$APP_PORT/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 30s
{{ if eq .Database.ServiceType "docker" }}

  db:
    build:
      context: .
      dockerfile: ./Dockerfile.pg
      args:
        - HTTP_PROXY=${HOST_PROXY}
        - HTTPS_PROXY=${HOST_PROXY}
        - NO_PROXY=localhost,127.0.0.1
    container_name: "local-webapp-db"
    restart: always
    volumes:
      - db-data:/var/lib/postgresql/data
      - ./db/initdb:/docker-entrypoint-initdb.d/
      - ./db/postgresql.conf:/etc/postgresql/custom/postgresql.conf
    command:
      - postgres
      - -c
      - config_file=/etc/postgresql/custom/postgresql.conf
      - -c
      - log_statement=all
      - -c
      - log_destination=stderr
      - -c
      - shared_preload_libraries=pg_cron
      - -c
      - cron.database_name=postgres
    environment:
      - POSTGRES_USER=${PG_USER}
      - POSTGRES_DB=postgres
      - POSTGRES_PASSWORD=${PG_PASSWORD}
      - APP_DB_NAME=${APP_DB_NAME}
      - APP_DB_USER=${APP_DB_USER}
      - APP_DB_PASSWORD=${APP_DB_PASSWORD}
      - PGTZ=UTC
    ports:
      - ${DB_PORT}:5432
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${PG_USER} -d postgres"]
      interval: 10s
      timeout: 5s
      retries: 5
{{ end }}
{{ if eq .Redis.ServiceType "docker" }}
  redis-acl-generator:
    image: alpine:latest
    container_name: "local-redis-acl-gen"
    environment:
      - REDIS_USER=${REDIS_USER}
      - REDIS_PASSWORD=${REDIS_PASSWORD}
      - REDISCLI_AUTH=${REDISCLI_AUTH}
    volumes:
      - ./redis:/src:ro
      - redis-config:/config
    command: |
      sh -c '
        cp /src/redis.conf /config/
        echo "user default +ping on >$$REDISCLI_AUTH" > /config/users.acl
        echo "user $$REDIS_USER +@all ~* on >$$REDIS_PASSWORD" >> /config/users.acl
        echo "ACL file generated successfully"
        cat /config/users.acl
      '

  redis:
    image: valkey/valkey:7.2-alpine
    container_name: "local-redis"
    depends_on:
      redis-acl-generator:
        condition: service_completed_successfully
    environment:
      - REDIS_USER=${REDIS_USER}
      - REDIS_PASSWORD=${REDIS_PASSWORD}
      - REDISCLI_AUTH=${REDISCLI_AUTH}
    volumes:
      - redis-data:/data
      - ./redis/redis.conf:/usr/local/etc/redis/redis.conf:ro
      - redis-config:/usr/local/etc/redis
    command: valkey-server /usr/local/etc/redis/redis.conf
    ports:
      - ${REDIS_PORT}:6379
    healthcheck:
      test: ["CMD", "valkey-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5
{{ end }}
  nginx:
    image: nginx:1.25.2-alpine
    container_name: "local-nginx"
    restart: always
    environment:
      - APP_LOCAL_HOST=webapp
      - APP_PORT=$APP_PORT
      - BASE_DOMAIN_NAME=$BASE_DOMAIN_NAME
    volumes:
      - ./static:/data/static
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
      - ./nginx/templates/webapp.conf.template:/etc/nginx/templates/webapp.conf.template:ro
      - ./nginx/logs:/etc/nginx/logs
      - /etc/letsencrypt:/etc/letsencrypt
    ports:
      - $NGINX_SSL_PORT:443
      - $NGINX_PORT:80
    depends_on:
      webapp:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:80/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 10s{{ if .GoAccess.Enabled }}
  goaccess:
    image: allinurl/goaccess:1.7.2
    container_name: "local-goaccess"
    restart: always
    entrypoint: 'sh -c "/bin/goaccess /data/logs/access.log -o /data/static/report.html --real-time-html --port=9880 --ssl-cert=$$SSL_CERT --ssl-key=$$SSL_KEY"'
    environment:
      - TZ="China/Shanghai"
      - SSL_CERT=/etc/letsencrypt/live/${BASE_DOMAIN_NAME}/fullchain.pem
      - SSL_KEY=/etc/letsencrypt/live/${BASE_DOMAIN_NAME}/privkey.pem
    volumes:
      - /var/www/goaccess:/var/www/goaccess:rw{{ if .GoAccess.HasGeoFile }}
      - ./geoip:/data/geoip:ro{{ end }}
      - /etc/letsencrypt:/etc/letsencrypt
      - ./goaccess.conf:/etc/goaccess/goaccess.conf
      - ./nginx/logs:/data/logs
      - ./manage_static:/data/static
    ports:
      - "9880:9880"{{ end }}

{{ if or (eq .Database.ServiceType "docker") (eq .Redis.ServiceType "docker") }}
volumes:{{ if eq .Database.ServiceType "docker" }}
  db-data:{{ end }}{{ if eq .Redis.ServiceType "docker" }}
  redis-data:
  redis-config:{{ end }}
{{ end }}
`

	// 解析模板
	tmpl, err := template.New("docker").Parse(dockerComposeTemplate)
	if err != nil {
		return fmt.Errorf("failed to parse docker template: %w", err)
	}

	// 创建输出文件
	filePath := filepath.Join(g.outputDir, "docker-compose.production.yml")
	file, err := os.Create(filePath)
	if err != nil {
		return fmt.Errorf("failed to create docker compose file: %w", err)
	}
	defer func() {
		if err := file.Close(); err != nil {
			log.Printf("Warning: failed to close docker compose file: %v", err)
		}
	}()

	// 执行模板
	if err := tmpl.Execute(file, cfg); err != nil {
		return fmt.Errorf("failed to execute docker template: %w", err)
	}

	// 只在选择docker模式时生成Redis配置文件和ACL文件
	if cfg.Redis.ServiceType == "docker" {
		if err := g.generateRedisConfig(cfg); err != nil {
			return fmt.Errorf("failed to generate redis config: %w", err)
		}
	}

	// 生成nginx配置
	if err := g.GenerateNginxConfig(cfg); err != nil {
		return fmt.Errorf("failed to generate nginx config: %w", err)
	}

	// 生成其他必要的配置文件
	if err := g.generateAdditionalConfigs(cfg); err != nil {
		return fmt.Errorf("failed to generate additional configs: %w", err)
	}

	return nil
}

// copyTemplateFiles 复制模板文件到config目录
func (g *GeneratorService) copyTemplateFiles(cfg *model.SetupConfig) error {
	// 只在选择docker模式时创建数据库配置
	if cfg.Database.ServiceType == "docker" {
		// 创建数据库配置目录
		dbDir := filepath.Join(g.outputDir, "db")
		if err := os.MkdirAll(dbDir, 0755); err != nil {
			return fmt.Errorf("failed to create db directory: %w", err)
		}

		// 复制数据库初始化脚本目录
		srcInitdbDir := "./templates/db/initdb"
		destInitdbDir := filepath.Join(dbDir, "initdb")
		if err := g.copyDir(srcInitdbDir, destInitdbDir); err != nil {
			return fmt.Errorf("failed to copy initdb directory: %w", err)
		}

		// 复制 PostgreSQL 配置文件
		srcPostgresqlConf := "./templates/db/postgresql.conf"
		destPostgresqlConf := filepath.Join(dbDir, "postgresql.conf")
		if err := g.copyFile(srcPostgresqlConf, destPostgresqlConf); err != nil {
			return fmt.Errorf("failed to copy postgresql.conf: %w", err)
		}

		// 复制 Dockerfile.pg 到配置根目录
		srcDockerfile := "./Dockerfile.pg"
		destDockerfile := filepath.Join(g.outputDir, "Dockerfile.pg")
		if err := g.copyFile(srcDockerfile, destDockerfile); err != nil {
			return fmt.Errorf("failed to copy Dockerfile.pg: %w", err)
		}
	}

	return nil
}

// copyFile 复制文件
func (g *GeneratorService) copyFile(src, dest string) error {
	sourceFile, err := os.Open(src)
	if err != nil {
		return err
	}
	defer sourceFile.Close()

	destFile, err := os.Create(dest)
	if err != nil {
		return err
	}
	defer destFile.Close()

	_, err = destFile.ReadFrom(sourceFile)
	return err
}

// copyDir 递归复制目录
func (g *GeneratorService) copyDir(src, dest string) error {
	srcInfo, err := os.Stat(src)
	if err != nil {
		return err
	}

	if err := os.MkdirAll(dest, srcInfo.Mode()); err != nil {
		return err
	}

	entries, err := os.ReadDir(src)
	if err != nil {
		return err
	}

	for _, entry := range entries {
		srcPath := filepath.Join(src, entry.Name())
		destPath := filepath.Join(dest, entry.Name())

		if entry.IsDir() {
			if err := g.copyDir(srcPath, destPath); err != nil {
				return err
			}
		} else {
			if err := g.copyFile(srcPath, destPath); err != nil {
				return err
			}
		}
	}

	return nil
}

// generateRedisConfig 生成Redis配置文件和ACL文件
func (g *GeneratorService) generateRedisConfig(cfg *model.SetupConfig) error {
	// 创建Redis目录
	redisDir := filepath.Join(g.outputDir, "redis")
	if err := os.MkdirAll(redisDir, 0755); err != nil {
		return fmt.Errorf("failed to create redis directory: %w", err)
	}

	// 读取redis.conf模板文件
	redisConfTemplate := "./templates/redis/redis.conf"
	redisConfContent, err := os.ReadFile(redisConfTemplate)
	if err != nil {
		return fmt.Errorf("failed to read redis.conf template: %w", err)
	}

	// 写入redis.conf到config/redis/目录
	redisConfPath := filepath.Join(redisDir, "redis.conf")
	if err := os.WriteFile(redisConfPath, redisConfContent, 0644); err != nil {
		return fmt.Errorf("failed to write redis.conf: %w", err)
	}

	// 读取并写入users.acl文件
	usersAclTemplatePath := "./templates/redis/users.acl.tpl"
	usersAclContent, err := os.ReadFile(usersAclTemplatePath)
	if err != nil {
		return fmt.Errorf("failed to read users.acl template: %w", err)
	}

	usersAclPath := filepath.Join(redisDir, "users.acl")
	if err := os.WriteFile(usersAclPath, usersAclContent, 0644); err != nil {
		return fmt.Errorf("failed to write users.acl: %w", err)
	}

	return nil
}

// GenerateNginxConfig 生成Nginx配置（使用templates模式）
func (g *GeneratorService) GenerateNginxConfig(cfg *model.SetupConfig) error {
	// 创建nginx目录结构
	nginxDir := filepath.Join(g.outputDir, "nginx")
	templatesDir := filepath.Join(nginxDir, "templates")
	if err := os.MkdirAll(templatesDir, 0755); err != nil {
		return fmt.Errorf("failed to create nginx directories: %w", err)
	}

	// 读取nginx.conf模板文件
	nginxConfTemplate := "./templates/nginx/nginx.conf"
	nginxConfContent, err := os.ReadFile(nginxConfTemplate)
	if err != nil {
		return fmt.Errorf("failed to read nginx.conf template: %w", err)
	}

	// 写入nginx.conf到config/nginx/目录
	nginxConfPath := filepath.Join(nginxDir, "nginx.conf")
	if err := os.WriteFile(nginxConfPath, nginxConfContent, 0644); err != nil {
		return fmt.Errorf("failed to write nginx.conf: %w", err)
	}

	// 读取webapp.conf.template模板文件
	webappTemplateFile := "./templates/nginx/webapp.conf.template"
	webappTemplateContent, err := os.ReadFile(webappTemplateFile)
	if err != nil {
		return fmt.Errorf("failed to read webapp.conf.template: %w", err)
	}

	// 写入webapp.conf.template到config/nginx/templates/目录
	webappTemplatePath := filepath.Join(templatesDir, "webapp.conf.template")
	if err := os.WriteFile(webappTemplatePath, webappTemplateContent, 0644); err != nil {
		return fmt.Errorf("failed to write webapp.conf.template: %w", err)
	}

	return nil
}

// generateSecretKey 生成密钥
func (g *GeneratorService) generateSecretKey(length int) string {
	bytes := make([]byte, length/2)
	if _, err := rand.Read(bytes); err != nil {
		// fallback to timestamp-based key if random fails
		return fmt.Sprintf("%x", time.Now().UnixNano())
	}
	return hex.EncodeToString(bytes)
}

// LogWriter 实时日志写入器
type LogWriter struct {
	level   string
	onWrite func(model.DeploymentLogEntry)
}

func (w *LogWriter) Write(p []byte) (n int, err error) {
	message := strings.TrimSpace(string(p))
	if message != "" {
		entry := model.DeploymentLogEntry{
			Timestamp: time.Now(),
			Level:     w.level,
			Message:   message,
		}
		w.onWrite(entry)
	}
	return len(p), nil
}

// StartDockerCompose 启动 Docker Compose（带实时日志）
func (g *GeneratorService) StartDockerCompose(onLog func(model.DeploymentLogEntry)) error {
	composeFile := filepath.Join(g.outputDir, "docker-compose.production.yml")
	if _, err := os.Stat(composeFile); os.IsNotExist(err) {
		return fmt.Errorf("docker-compose.production.yml not found in %s, please generate configuration first", g.outputDir)
	}

	// 记录命令开始
	onLog(model.DeploymentLogEntry{
		Timestamp: time.Now(),
		Level:     "info",
		Message:   "Starting Docker Compose deployment...",
	})

	// 构建命令
	cmdArgs := []string{"-f", composeFile, "up", "-d"}
	onLog(model.DeploymentLogEntry{
		Timestamp: time.Now(),
		Level:     "cmd",
		Message:   fmt.Sprintf("docker-compose %s", strings.Join(cmdArgs, " ")),
	})

	// 创建命令
	cmd := exec.Command("docker-compose", cmdArgs...)
	// 工作目录设为setup根目录，这样docker-compose.yml中的相对路径才能正确工作
	cmd.Dir = "./"
	cmd.Env = append(os.Environ(), "COMPOSE_PROJECT_NAME=baklab")

	// 设置实时输出
	stdoutWriter := &LogWriter{level: "stdout", onWrite: onLog}
	stderrWriter := &LogWriter{level: "stderr", onWrite: onLog}
	cmd.Stdout = stdoutWriter
	cmd.Stderr = stderrWriter

	// 执行命令
	if err := cmd.Run(); err != nil {
		onLog(model.DeploymentLogEntry{
			Timestamp: time.Now(),
			Level:     "error",
			Message:   fmt.Sprintf("docker-compose failed: %v", err),
		})
		return fmt.Errorf("docker-compose failed: %w", err)
	}

	onLog(model.DeploymentLogEntry{
		Timestamp: time.Now(),
		Level:     "success",
		Message:   "Docker Compose started successfully",
	})

	return nil
}

// generateAdditionalConfigs 生成其他必要的配置文件
func (g *GeneratorService) generateAdditionalConfigs(cfg *model.SetupConfig) error {
	// 生成 GoAccess 配置文件（仅在启用时）
	if cfg.GoAccess.Enabled {
		if err := g.generateGoAccessConfig(); err != nil {
			return fmt.Errorf("failed to generate goaccess config: %w", err)
		}
	}

	if err := g.copyStaticFiles(); err != nil {
		return fmt.Errorf("failed to create static directory: %w", err)
	}

	// 创建 keys 目录和文档
	if err := g.createKeysDirectory(); err != nil {
		return fmt.Errorf("failed to create keys directory: %w", err)
	}

	// 创建其他必要目录
	if err := g.createRequiredDirectories(cfg); err != nil {
		return fmt.Errorf("failed to create required directories: %w", err)
	}

	return nil
}

// generateGoAccessConfig 生成 GoAccess 配置文件
func (g *GeneratorService) generateGoAccessConfig() error {
	goAccessConfig := `time-format %T
date-format %d/%b/%Y
log_format %h - %^ [%d:%t %^]  %s "%r" %b "%R" "%u" "%^"
geoip-database /data/geoip/GeoLite2-City.mmdb`

	filePath := filepath.Join(g.outputDir, "goaccess.conf")
	if err := os.WriteFile(filePath, []byte(goAccessConfig), 0644); err != nil {
		return fmt.Errorf("failed to write goaccess.conf: %w", err)
	}

	return nil
}

// copyStaticFiles 创建静态资源目录
func (g *GeneratorService) copyStaticFiles() error {
	staticDir := filepath.Join(g.outputDir, "static")
	if err := os.MkdirAll(staticDir, 0755); err != nil {
		return fmt.Errorf("failed to create static directory: %w", err)
	}

	// 创建基本的静态文件占位，供nginx配置使用
	robotsContent := `User-agent: *
Allow: /

Sitemap: https://example.com/sitemap.xml`

	robotsPath := filepath.Join(staticDir, "robots.txt")
	if err := os.WriteFile(robotsPath, []byte(robotsContent), 0644); err != nil {
		return fmt.Errorf("failed to create robots.txt: %w", err)
	}

	return nil
}

// createKeysDirectory 创建 keys 目录和相关文档
func (g *GeneratorService) createKeysDirectory() error {
	keysDir := filepath.Join(g.outputDir, "keys")
	if err := os.MkdirAll(keysDir, 0755); err != nil {
		return fmt.Errorf("failed to create keys directory: %w", err)
	}

	// 检查源 keys 目录是否有 README.md
	srcKeysReadme := "./keys/README.md"
	if _, err := os.Stat(srcKeysReadme); err == nil {
		destKeysReadme := filepath.Join(keysDir, "README.md")
		if err := g.copyFile(srcKeysReadme, destKeysReadme); err != nil {
			return fmt.Errorf("failed to copy keys README.md: %w", err)
		}
	} else {
		// 创建基本的 keys 说明文档
		keysReadmeContent := `# JWT Key Management

This directory contains JWT signing keys for the application.

## Setup Instructions

1. Generate Ed25519 key for JWT signing:
   ` + "```bash" + `
   openssl genpkey -algorithm Ed25519 -out jwt-ed25519.pem
   chmod 600 jwt-ed25519.pem
   ` + "```" + `

2. Or generate RSA key (alternative):
   ` + "```bash" + `
   openssl genrsa -out jwt-rsa.pem 3072
   chmod 600 jwt-rsa.pem
   ` + "```" + `

## Security Notes

- Never commit private keys to version control
- Set proper file permissions (600) for private keys
- Use different keys for different environments`

		readmePath := filepath.Join(keysDir, "README.md")
		if err := os.WriteFile(readmePath, []byte(keysReadmeContent), 0644); err != nil {
			return fmt.Errorf("failed to create keys README.md: %w", err)
		}
	}

	return nil
}

// createRequiredDirectories 创建其他必要目录
func (g *GeneratorService) createRequiredDirectories(cfg *model.SetupConfig) error {
	// 创建 manage_static 目录
	manageStaticDir := filepath.Join(g.outputDir, "manage_static")
	if err := os.MkdirAll(manageStaticDir, 0755); err != nil {
		return fmt.Errorf("failed to create manage_static directory: %w", err)
	}

	// 创建 .gitkeep 文件
	gitkeepPath := filepath.Join(manageStaticDir, ".gitkeep")
	if err := os.WriteFile(gitkeepPath, []byte{}, 0644); err != nil {
		return fmt.Errorf("failed to create .gitkeep: %w", err)
	}

	// 创建 geoip 目录
	geoipDir := filepath.Join(g.outputDir, "geoip")
	if err := os.MkdirAll(geoipDir, 0755); err != nil {
		return fmt.Errorf("failed to create geoip directory: %w", err)
	}

	// 如果启用了 GoAccess 且有上传的 GeoIP 文件，从临时目录复制到输出目录
	if cfg.GoAccess.Enabled && cfg.GoAccess.HasGeoFile && cfg.GoAccess.GeoTempPath != "" {
		tempGeoipFile := cfg.GoAccess.GeoTempPath
		destGeoipFile := filepath.Join(geoipDir, "GeoLite2-City.mmdb")

		if _, err := os.Stat(tempGeoipFile); err == nil {
			// 从临时目录复制 GeoIP 数据库文件
			if err := g.copyFile(tempGeoipFile, destGeoipFile); err != nil {
				return fmt.Errorf("failed to copy GeoIP database from temp: %w", err)
			}
			
			// 复制成功后删除临时文件
			if err := os.Remove(tempGeoipFile); err != nil {
				log.Printf("Warning: failed to remove temporary GeoIP file %s: %v", tempGeoipFile, err)
			} else {
				log.Printf("Temporary GeoIP file %s removed successfully", tempGeoipFile)
			}
			
			log.Printf("Copied GeoIP file from temp directory to output: %s", destGeoipFile)
		} else {
			return fmt.Errorf("GeoIP database file no longer available. The uploaded file may have been cleared. Please re-upload your GeoIP database file and try again")
		}
	}

	// 检查是否存在传统的源 geoip 文件（向后兼容）
	srcGeoipFile := "./geoip/Country.mmdb"
	destCountryFile := filepath.Join(geoipDir, "Country.mmdb")
	if _, err := os.Stat(srcGeoipFile); err == nil {
		// 复制传统的 Country.mmdb 文件
		if err := g.copyFile(srcGeoipFile, destCountryFile); err != nil {
			return fmt.Errorf("failed to copy traditional GeoIP database: %w", err)
		}
	}

	// 如果没有任何 GeoIP 文件，创建占位文件
	hasAnyGeoFile := false
	cityFile := filepath.Join(geoipDir, "GeoLite2-City.mmdb")
	countryFile := filepath.Join(geoipDir, "Country.mmdb")

	if _, err := os.Stat(cityFile); err == nil {
		hasAnyGeoFile = true
	}
	if _, err := os.Stat(countryFile); err == nil {
		hasAnyGeoFile = true
	}

	if !hasAnyGeoFile {
		// 创建占位文件
		gitkeepGeoipPath := filepath.Join(geoipDir, ".gitkeep")
		if err := os.WriteFile(gitkeepGeoipPath, []byte{}, 0644); err != nil {
			return fmt.Errorf("failed to create geoip .gitkeep: %w", err)
		}
	}

	return nil
}

// HandleJWTKeyFile 处理JWT密钥文件
func (g *GeneratorService) HandleJWTKeyFile(cfg *model.SetupConfig) error {
	// 如果用户上传了JWT密钥文件，需要复制到keys目录
	if cfg.App.HasJWTKeyFile && cfg.App.JWTKeyTempPath != "" {
		// 获取临时文件路径
		tempPath := cfg.App.JWTKeyTempPath
		if _, err := os.Stat(tempPath); os.IsNotExist(err) {
			return fmt.Errorf("JWT key file no longer available. The uploaded file may have been cleared. Please re-upload your JWT key file and try again")
		}

		// 确保keys目录存在
		keysDir := filepath.Join(g.outputDir, "keys")
		if err := os.MkdirAll(keysDir, 0755); err != nil {
			return fmt.Errorf("failed to create keys directory: %w", err)
		}

		// 生成标准的JWT密钥文件名
		destPath := filepath.Join(keysDir, "jwt-private.pem")
		
		// 复制文件
		if err := g.copyFile(tempPath, destPath); err != nil {
			return fmt.Errorf("failed to copy JWT key file: %w", err)
		}

		// 设置正确的文件权限（600 - 只有所有者可读写）
		if err := os.Chmod(destPath, 0600); err != nil {
			return fmt.Errorf("failed to set JWT key file permissions: %w", err)
		}

		// 复制成功后删除临时文件
		if err := os.Remove(tempPath); err != nil {
			log.Printf("Warning: failed to remove temporary JWT key file %s: %v", tempPath, err)
		} else {
			log.Printf("Temporary JWT key file %s removed successfully", tempPath)
		}

		log.Printf("JWT key file copied to: %s", destPath)
	}

	return nil
}
