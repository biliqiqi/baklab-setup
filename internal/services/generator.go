package services

import (
	"crypto/rand"
	"encoding/hex"
	"fmt"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"text/template"
	"time"

	"github.com/oodzchen/baklab/setup/internal/config"
)

// GeneratorService 配置文件生成服务
type GeneratorService struct {
	outputDir string
}

// NewGeneratorService 创建生成器服务实例
func NewGeneratorService() *GeneratorService {
	return &GeneratorService{
		outputDir: "./config", // 输出到setup目录下的config子目录
	}
}

// SetOutputDir 设置输出目录
func (g *GeneratorService) SetOutputDir(dir string) {
	g.outputDir = dir
}

// ClearOutputDir 清空输出目录
func (g *GeneratorService) ClearOutputDir() error {
	// 检查目录是否存在
	if _, err := os.Stat(g.outputDir); os.IsNotExist(err) {
		// 目录不存在，无需清理
		return nil
	}
	
	// 删除整个目录及其内容
	if err := os.RemoveAll(g.outputDir); err != nil {
		return fmt.Errorf("failed to clear output directory: %w", err)
	}
	
	return nil
}

// GenerateEnvFile 生成.env文件
func (g *GeneratorService) GenerateEnvFile(cfg *config.SetupConfig) error {
	// 确保输出目录和子目录存在
	if err := os.MkdirAll(g.outputDir, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}
	
	// 创建必要的子目录
	certsDir := filepath.Join(g.outputDir, "certs")
	if err := os.MkdirAll(certsDir, 0755); err != nil {
		return fmt.Errorf("failed to create certs directory: %w", err)
	}
	
	dataDir := filepath.Join("./data")
	if err := os.MkdirAll(dataDir, 0755); err != nil {
		return fmt.Errorf("failed to create data directory: %w", err)
	}
	
	logsDir := filepath.Join("./data/logs")
	if err := os.MkdirAll(logsDir, 0755); err != nil {
		return fmt.Errorf("failed to create logs directory: %w", err)
	}
	
	// 生成缺失的密钥
	if cfg.App.SessionSecret == "" {
		cfg.App.SessionSecret = g.generateSecretKey(64)
	}
	if cfg.App.CSRFSecret == "" {
		cfg.App.CSRFSecret = g.generateSecretKey(64)
	}
	
	// 环境配置模板
	envTemplate := `# Generated by baklab setup service
# Generated at: {{ .Timestamp }}

# Language Configuration
DEFAULT_LANG={{ .App.DefaultLang }}

# Database Configuration
DB_HOST={{ .Database.Host }}
DB_PORT={{ .Database.Port }}
PG_USER={{ .Database.User }}
PG_PASSWORD={{ .Database.Password }}
APP_DB_NAME={{ .Database.Name }}
APP_DB_USER={{ .Database.User }}
APP_DB_PASSWORD={{ .Database.Password }}

# Redis Configuration
REDIS_HOST={{ .Redis.Host }}
REDIS_PORT={{ .Redis.Port }}
REDIS_USER={{ if .Redis.User }}{{ .Redis.User }}{{ else }}user{{ end }}
REDIS_PASSWORD={{ .Redis.Password }}
REDISCLI_AUTH={{ .Redis.Password }}

# Application Configuration
DOMAIN_NAME={{ .App.DomainName }}
SECOND_LEVEL_DOMAIN_NAME={{ .App.DomainName }}
BRAND_NAME={{ .App.BrandName }}
BRAND_DOMAIN_NAME={{ .App.DomainName }}
ADMIN_EMAIL={{ .App.AdminEmail }}
ADMIN_PASSWORD={{ .Database.Password }}
DEBUG={{ .App.Debug }}
TEST=false
APP_VERSION={{ if .App.Version }}{{ .App.Version }}{{ else }}latest{{ end }}

# Security Configuration
SESSION_SECRET={{ .App.SessionSecret }}
CSRF_SECRET={{ .App.CSRFSecret }}
JWT_KEY_FILE=./keys/jwt-ed25519.pem

# Application Ports
APP_PORT=3000
APP_OUTER_PORT=3000
FRONTEND_PORT=5173
NGINX_PORT=80
NGINX_SSL_PORT=443

# Network Configuration
{{ if .CORSOrigins }}CORS_ALLOW_ORIGINS={{ .CORSOrigins }}{{ else }}CORS_ALLOW_ORIGINS=http{{ if ne .App.DomainName "localhost" }}s{{ end }}://{{ .App.DomainName }}{{ end }}

# Frontend Configuration
FRONTEND_ROOT_ID=root
FRONTEND_SCRIPTS=
FRONTEND_STYLES=

# Service Configuration
SERVICE_URL=http{{ if ne .App.DomainName "localhost" }}s{{ end }}://{{ .App.DomainName }}{{ if eq .App.DomainName "localhost" }}:3000{{ end }}
STATIC_HOST_NAME={{ .App.DomainName }}{{ if eq .App.DomainName "localhost" }}:8787{{ end }}

# OAuth Configuration (optional)
{{ if .App.GoogleClientID }}GOOGLE_CLIENT_ID={{ .App.GoogleClientID }}{{ else }}GOOGLE_CLIENT_ID={{ end }}
{{ if .App.GoogleSecret }}GOOGLE_CLIENT_SECRET={{ .App.GoogleSecret }}{{ else }}GOOGLE_CLIENT_SECRET={{ end }}
{{ if .App.GithubClientID }}GITHUB_CLIENT_ID={{ .App.GithubClientID }}{{ else }}GITHUB_CLIENT_ID={{ end }}
{{ if .App.GithubSecret }}GITHUB_CLIENT_SECRET={{ .App.GithubSecret }}{{ else }}GITHUB_CLIENT_SECRET={{ end }}

# Cloudflare Configuration (optional)
{{ if .App.CloudflareSiteKey }}CLOUDFLARE_SITE_KEY={{ .App.CloudflareSiteKey }}{{ else }}CLOUDFLARE_SITE_KEY={{ end }}
{{ if .App.CloudflareSecret }}CLOUDFLARE_SECRET={{ .App.CloudflareSecret }}{{ else }}CLOUDFLARE_SECRET={{ end }}

# SMTP Configuration (optional)
{{ if .SMTP.Server }}SMTP_SERVER={{ .SMTP.Server }}{{ else }}SMTP_SERVER={{ end }}
SMTP_SERVER_PORT={{ if .SMTP.Port }}{{ .SMTP.Port }}{{ else }}587{{ end }}
{{ if .SMTP.User }}SMTP_USER={{ .SMTP.User }}{{ else }}SMTP_USER={{ end }}
{{ if .SMTP.Password }}SMTP_PASSWORD={{ .SMTP.Password }}{{ else }}SMTP_PASSWORD={{ end }}
{{ if .SMTP.Sender }}SMTP_SENDER={{ .SMTP.Sender }}{{ else }}SMTP_SENDER=noreply@{{ .App.DomainName }}{{ end }}

# File Paths
GEOIP_ENABLED=false
GEOIP_FILE=./geoip/Country.mmdb
I18N_FILE_DIR=./i18n
MIGRATION_FILE_DIR=./config/db/migrations
DEFAULT_DATA_DIR=./config/defaults

# Development Configuration
HOST_PROXY=http://127.0.0.1:1008
APP_LOCAL_HOST=172.17.0.1

# TLS Configuration (uncomment to enable)
# APP_AUTOCERT=1
# APP_TLS_CERT=./certs/server.crt
# APP_TLS_KEY=./certs/server.key

# Version
APP_VERSION={{ if .App.Version }}{{ .App.Version }}{{ else }}latest{{ end }}

# Setup Status
SETUP_COMPLETED=true
SETUP_COMPLETED_AT={{ .Timestamp }}
`
	
	// 解析模板
	tmpl, err := template.New("env").Parse(envTemplate)
	if err != nil {
		return fmt.Errorf("failed to parse env template: %w", err)
	}
	
	// 准备CORS配置字符串
	corsOrigins := ""
	if len(cfg.App.CORSAllowOrigins) > 0 {
		corsOrigins = strings.Join(cfg.App.CORSAllowOrigins, ",")
	}
	
	// 准备模板数据
	data := struct {
		*config.SetupConfig
		Timestamp   string
		CORSOrigins string
	}{
		SetupConfig: cfg,
		Timestamp:   time.Now().Format(time.RFC3339),
		CORSOrigins: corsOrigins,
	}
	
	// 创建输出文件
	filePath := filepath.Join(g.outputDir, ".env.production")
	file, err := os.Create(filePath)
	if err != nil {
		return fmt.Errorf("failed to create env file: %w", err)
	}
	defer func() {
		if err := file.Close(); err != nil {
			log.Printf("Warning: failed to close env file: %v", err)
		}
	}()
	
	// 执行模板
	if err := tmpl.Execute(file, data); err != nil {
		return fmt.Errorf("failed to execute env template: %w", err)
	}
	
	return nil
}

// GenerateDockerConfig 生成Docker配置文件
func (g *GeneratorService) GenerateDockerConfig(cfg *config.SetupConfig) error {
	// 首先复制必要的模板文件到config目录
	if err := g.copyTemplateFiles(); err != nil {
		return fmt.Errorf("failed to copy template files: %w", err)
	}
	dockerComposeTemplate := `# Generated by baklab setup service
# Production Docker Compose Configuration

services:
  webapp:
    image: ghcr.io/biliqiqi/baklab:$APP_VERSION
    container_name: "webapp-app-1"
    restart: always
    environment:
      DB_CONTAINER_NAME: "local-webapp-db"
      DB_HOST: "db"
      DB_PORT: 5432
      DOMAIN_NAME: $DOMAIN_NAME
      DB_NAME: $APP_DB_NAME
      DB_USER: $APP_DB_USER
      ADMIN_PASSWORD: $ADMIN_PASSWORD
      ADMIN_EMAIL: $ADMIN_EMAIL
      APP_PORT: $APP_PORT
      APP_OUTER_PORT: $APP_OUTER_PORT
      NGINX_PORT: $NGINX_PORT
      NGINX_SSL_PORT: $NGINX_SSL_PORT
      SESSION_SECRET: $SESSION_SECRET
      CSRF_SECRET: $CSRF_SECRET
      REDIS_HOST: "redis"
      REDIS_PORT: 6379
      REDIS_USER: $REDIS_USER
      REDIS_PASSWORD: $REDIS_PASSWORD
      REDISCLI_AUTH: $REDISCLI_AUTH
      SMTP_SERVER: $SMTP_SERVER
      SMTP_SERVER_PORT: $SMTP_SERVER_PORT
      SMTP_USER: $SMTP_USER
      SMTP_PASSWORD: $SMTP_PASSWORD
      SMTP_SENDER: $SMTP_SENDER
      GOOGLE_CLIENT_ID: $GOOGLE_CLIENT_ID
      GOOGLE_CLIENT_SECRET: $GOOGLE_CLIENT_SECRET
      GITHUB_CLIENT_ID: $GITHUB_CLIENT_ID
      GITHUB_CLIENT_SECRET: $GITHUB_CLIENT_SECRET
      APP_VERSION: $APP_VERSION
      CLOUDFLARE_SITE_KEY: $CLOUDFLARE_SITE_KEY
      CLOUDFLARE_SECRET: $CLOUDFLARE_SECRET
    volumes:
      - ./manage_static:/app/manage_static
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_healthy
    links:
      - db
      - redis

  db:
    build:
      context: .
      dockerfile: ./config/Dockerfile.pg
      args:
        - HTTP_PROXY=${HOST_PROXY}
        - HTTPS_PROXY=${HOST_PROXY}
        - NO_PROXY=localhost,127.0.0.1
    container_name: "local-webapp-db"
    restart: always
    volumes:
      - db-data:/var/lib/postgresql/data
      - ./config/db/initdb:/docker-entrypoint-initdb.d/
      - ./config/db/postgresql.conf:/etc/postgresql/custom/postgresql.conf
    command:
      - postgres
      - -c
      - config_file=/etc/postgresql/custom/postgresql.conf
      - -c
      - log_statement=all
      - -c
      - log_destination=stderr
      - -c
      - shared_preload_libraries=pg_cron
      - -c
      - cron.database_name=postgres
    environment:
      - POSTGRES_USER=${PG_USER}
      - POSTGRES_DB=postgres
      - POSTGRES_PASSWORD=${PG_PASSWORD}
      - APP_DB_NAME=${APP_DB_NAME}
      - APP_DB_USER=${APP_DB_USER}
      - APP_DB_PASSWORD=${APP_DB_PASSWORD}
      - PGTZ=UTC
    ports:
      - ${DB_PORT}:5432
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${PG_USER} -d postgres"]
      interval: 10s
      timeout: 5s
      retries: 5

  redis-acl-generator:
    image: alpine:latest
    container_name: "local-redis-acl-gen"
    environment:
      - REDIS_USER=${REDIS_USER}
      - REDIS_PASSWORD=${REDIS_PASSWORD}
      - REDISCLI_AUTH=${REDISCLI_AUTH}
    volumes:
      - ./templates/redis:/src:ro
      - redis-config:/config
    command: |
      sh -c '
        cp /src/redis.conf /config/
        echo "user default +ping on >$$REDISCLI_AUTH" > /config/users.acl
        echo "user $$REDIS_USER +@all ~* on >$$REDIS_PASSWORD" >> /config/users.acl
        echo "ACL file generated successfully"
        cat /config/users.acl
      '

  redis:
    image: valkey/valkey:7.2-alpine
    container_name: "local-redis"
    depends_on:
      redis-acl-generator:
        condition: service_completed_successfully
    environment:
      - REDIS_USER=${REDIS_USER}
      - REDIS_PASSWORD=${REDIS_PASSWORD}
      - REDISCLI_AUTH=${REDISCLI_AUTH}
    volumes:
      - redis-data:/data
      - ./config/redis/redis.conf:/usr/local/etc/redis/redis.conf:ro
      - redis-config:/usr/local/etc/redis
    command: valkey-server /usr/local/etc/redis/redis.conf
    ports:
      - ${REDIS_PORT}:6379
    healthcheck:
      test: ["CMD", "valkey-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5

  nginx:
    image: nginx:1.25.2-alpine
    container_name: "local-nginx"
    restart: always
    environment:
      - APP_LOCAL_HOST=webapp
      - APP_PORT=$APP_PORT
      - SECOND_LEVEL_DOMAIN_NAME=$SECOND_LEVEL_DOMAIN_NAME
    volumes:
      - ./static:/data/static
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
      - ./nginx/templates/webapp.conf.template:/etc/nginx/templates/webapp.conf.template:ro
      - ./nginx/logs:/etc/nginx/logs
      - /etc/letsencrypt:/etc/letsencrypt
    ports:
      - $NGINX_SSL_PORT:443
      - $NGINX_PORT:80
    depends_on:
      - webapp
  goaccess:
    image: allinurl/goaccess:1.7.2
    container_name: "local-goaccess"
    restart: always
    entrypoint: 'sh -c "/bin/goaccess /data/logs/access.log -o /data/static/report.html --real-time-html --port=9880 --ssl-cert=$$SSL_CERT --ssl-key=$$SSL_KEY"'
    environment:
      - TZ="China/Shanghai"
      - SSL_CERT=/etc/letsencrypt/live/${SECOND_LEVEL_DOMAIN_NAME}/fullchain.pem
      - SSL_KEY=/etc/letsencrypt/live/${SECOND_LEVEL_DOMAIN_NAME}/privkey.pem
    volumes:
      - /var/www/goaccess:/var/www/goaccess:rw
      - ./geoip/GeoLite2-City.mmdb:/data/GeoLite2-City.mmdb
      - /etc/letsencrypt:/etc/letsencrypt
      - ./goaccess.conf:/etc/goaccess/goaccess.conf
      - ./nginx/logs:/data/logs
      - ./manage_static:/data/static
    ports:
      - "9880:9880"

volumes:
  db-data:
  redis-data:
  redis-config:
`
	
	// 解析模板
	tmpl, err := template.New("docker").Parse(dockerComposeTemplate)
	if err != nil {
		return fmt.Errorf("failed to parse docker template: %w", err)
	}
	
	// 创建输出文件
	filePath := filepath.Join(g.outputDir, "docker-compose.production.yml")
	file, err := os.Create(filePath)
	if err != nil {
		return fmt.Errorf("failed to create docker compose file: %w", err)
	}
	defer func() {
		if err := file.Close(); err != nil {
			log.Printf("Warning: failed to close docker compose file: %v", err)
		}
	}()
	
	// 执行模板
	if err := tmpl.Execute(file, cfg); err != nil {
		return fmt.Errorf("failed to execute docker template: %w", err)
	}
	
	// 生成Redis配置文件和ACL文件
	if err := g.generateRedisConfig(cfg); err != nil {
		return fmt.Errorf("failed to generate redis config: %w", err)
	}
	
	// 生成nginx配置
	if err := g.GenerateNginxConfig(cfg); err != nil {
		return fmt.Errorf("failed to generate nginx config: %w", err)
	}
	
	// 生成其他必要的配置文件
	if err := g.generateAdditionalConfigs(cfg); err != nil {
		return fmt.Errorf("failed to generate additional configs: %w", err)
	}
	
	return nil
}

// copyTemplateFiles 复制模板文件到config目录
func (g *GeneratorService) copyTemplateFiles() error {
	// 创建数据库配置目录
	dbDir := filepath.Join(g.outputDir, "db")
	if err := os.MkdirAll(dbDir, 0755); err != nil {
		return fmt.Errorf("failed to create db directory: %w", err)
	}
	
	// 复制数据库初始化脚本目录
	srcInitdbDir := "./templates/db/initdb"
	destInitdbDir := filepath.Join(dbDir, "initdb")
	if err := g.copyDir(srcInitdbDir, destInitdbDir); err != nil {
		return fmt.Errorf("failed to copy initdb directory: %w", err)
	}
	
	// 复制 PostgreSQL 配置文件
	srcPostgresqlConf := "./templates/db/postgresql.conf"
	destPostgresqlConf := filepath.Join(dbDir, "postgresql.conf")
	if err := g.copyFile(srcPostgresqlConf, destPostgresqlConf); err != nil {
		return fmt.Errorf("failed to copy postgresql.conf: %w", err)
	}
	
	// 复制 Dockerfile.pg 到配置根目录
	srcDockerfile := "./Dockerfile.pg"
	destDockerfile := filepath.Join(g.outputDir, "Dockerfile.pg")
	if err := g.copyFile(srcDockerfile, destDockerfile); err != nil {
		return fmt.Errorf("failed to copy Dockerfile.pg: %w", err)
	}
	
	return nil
}

// copyFile 复制文件
func (g *GeneratorService) copyFile(src, dest string) error {
	sourceFile, err := os.Open(src)
	if err != nil {
		return err
	}
	defer sourceFile.Close()
	
	destFile, err := os.Create(dest)
	if err != nil {
		return err
	}
	defer destFile.Close()
	
	_, err = destFile.ReadFrom(sourceFile)
	return err
}

// copyDir 递归复制目录
func (g *GeneratorService) copyDir(src, dest string) error {
	srcInfo, err := os.Stat(src)
	if err != nil {
		return err
	}
	
	if err := os.MkdirAll(dest, srcInfo.Mode()); err != nil {
		return err
	}
	
	entries, err := os.ReadDir(src)
	if err != nil {
		return err
	}
	
	for _, entry := range entries {
		srcPath := filepath.Join(src, entry.Name())
		destPath := filepath.Join(dest, entry.Name())
		
		if entry.IsDir() {
			if err := g.copyDir(srcPath, destPath); err != nil {
				return err
			}
		} else {
			if err := g.copyFile(srcPath, destPath); err != nil {
				return err
			}
		}
	}
	
	return nil
}

// generateRedisConfig 生成Redis配置文件和ACL文件
func (g *GeneratorService) generateRedisConfig(cfg *config.SetupConfig) error {
	// 创建Redis目录
	redisDir := filepath.Join(g.outputDir, "redis")
	if err := os.MkdirAll(redisDir, 0755); err != nil {
		return fmt.Errorf("failed to create redis directory: %w", err)
	}
	
	// 读取redis.conf模板文件
	redisConfTemplate := "./templates/redis/redis.conf"
	redisConfContent, err := os.ReadFile(redisConfTemplate)
	if err != nil {
		return fmt.Errorf("failed to read redis.conf template: %w", err)
	}
	
	// 写入redis.conf到config/redis/目录
	redisConfPath := filepath.Join(redisDir, "redis.conf")
	if err := os.WriteFile(redisConfPath, redisConfContent, 0644); err != nil {
		return fmt.Errorf("failed to write redis.conf: %w", err)
	}
	
	// 读取并写入users.acl文件
	usersAclTemplatePath := "./templates/redis/users.acl.tpl"
	usersAclContent, err := os.ReadFile(usersAclTemplatePath)
	if err != nil {
		return fmt.Errorf("failed to read users.acl template: %w", err)
	}
	
	usersAclPath := filepath.Join(redisDir, "users.acl")
	if err := os.WriteFile(usersAclPath, usersAclContent, 0644); err != nil {
		return fmt.Errorf("failed to write users.acl: %w", err)
	}
	
	return nil
}

// GenerateNginxConfig 生成Nginx配置（使用templates模式）
func (g *GeneratorService) GenerateNginxConfig(cfg *config.SetupConfig) error {
	// 创建nginx目录结构
	nginxDir := filepath.Join(g.outputDir, "nginx")
	templatesDir := filepath.Join(nginxDir, "templates")
	if err := os.MkdirAll(templatesDir, 0755); err != nil {
		return fmt.Errorf("failed to create nginx directories: %w", err)
	}
	
	// 读取nginx.conf模板文件
	nginxConfTemplate := "./templates/nginx/nginx.conf"
	nginxConfContent, err := os.ReadFile(nginxConfTemplate)
	if err != nil {
		return fmt.Errorf("failed to read nginx.conf template: %w", err)
	}
	
	// 写入nginx.conf到config/nginx/目录
	nginxConfPath := filepath.Join(nginxDir, "nginx.conf")
	if err := os.WriteFile(nginxConfPath, nginxConfContent, 0644); err != nil {
		return fmt.Errorf("failed to write nginx.conf: %w", err)
	}
	
	// 读取webapp.conf.template模板文件
	webappTemplateFile := "./templates/nginx/webapp.conf.template"
	webappTemplateContent, err := os.ReadFile(webappTemplateFile)
	if err != nil {
		return fmt.Errorf("failed to read webapp.conf.template: %w", err)
	}
	
	// 写入webapp.conf.template到config/nginx/templates/目录
	webappTemplatePath := filepath.Join(templatesDir, "webapp.conf.template")
	if err := os.WriteFile(webappTemplatePath, webappTemplateContent, 0644); err != nil {
		return fmt.Errorf("failed to write webapp.conf.template: %w", err)
	}
	
	return nil
}


// generateSecretKey 生成密钥
func (g *GeneratorService) generateSecretKey(length int) string {
	bytes := make([]byte, length/2)
	if _, err := rand.Read(bytes); err != nil {
		// fallback to timestamp-based key if random fails
		return fmt.Sprintf("%x", time.Now().UnixNano())
	}
	return hex.EncodeToString(bytes)
}

// LogWriter 实时日志写入器
type LogWriter struct {
	level   string
	onWrite func(config.DeploymentLogEntry)
}

func (w *LogWriter) Write(p []byte) (n int, err error) {
	message := strings.TrimSpace(string(p))
	if message != "" {
		entry := config.DeploymentLogEntry{
			Timestamp: time.Now(),
			Level:     w.level,
			Message:   message,
		}
		w.onWrite(entry)
	}
	return len(p), nil
}

// StartDockerCompose 启动 Docker Compose（带实时日志）
func (g *GeneratorService) StartDockerCompose(onLog func(config.DeploymentLogEntry)) error {
	composeFile := filepath.Join(g.outputDir, "docker-compose.production.yml")
	if _, err := os.Stat(composeFile); os.IsNotExist(err) {
		return fmt.Errorf("docker-compose.production.yml not found in %s, please generate configuration first", g.outputDir)
	}
	
	// 记录命令开始
	onLog(config.DeploymentLogEntry{
		Timestamp: time.Now(),
		Level:     "info",
		Message:   "Starting Docker Compose deployment...",
	})
	
	// 构建命令
	cmdArgs := []string{"-f", composeFile, "up", "-d"}
	onLog(config.DeploymentLogEntry{
		Timestamp: time.Now(),
		Level:     "cmd",
		Message:   fmt.Sprintf("docker-compose %s", strings.Join(cmdArgs, " ")),
	})
	
	// 创建命令
	cmd := exec.Command("docker-compose", cmdArgs...)
	// 工作目录设为setup根目录，这样docker-compose.yml中的相对路径才能正确工作
	cmd.Dir = "./"
	cmd.Env = append(os.Environ(), "COMPOSE_PROJECT_NAME=baklab")
	
	// 设置实时输出
	stdoutWriter := &LogWriter{level: "stdout", onWrite: onLog}
	stderrWriter := &LogWriter{level: "stderr", onWrite: onLog}
	cmd.Stdout = stdoutWriter
	cmd.Stderr = stderrWriter
	
	// 执行命令
	if err := cmd.Run(); err != nil {
		onLog(config.DeploymentLogEntry{
			Timestamp: time.Now(),
			Level:     "error",
			Message:   fmt.Sprintf("docker-compose failed: %v", err),
		})
		return fmt.Errorf("docker-compose failed: %w", err)
	}
	
	onLog(config.DeploymentLogEntry{
		Timestamp: time.Now(),
		Level:     "success",
		Message:   "Docker Compose started successfully",
	})
	
	return nil
}

// generateAdditionalConfigs 生成其他必要的配置文件
func (g *GeneratorService) generateAdditionalConfigs(cfg *config.SetupConfig) error {
	// 生成 GoAccess 配置文件
	if err := g.generateGoAccessConfig(); err != nil {
		return fmt.Errorf("failed to generate goaccess config: %w", err)
	}
	
	// 复制静态资源文件
	if err := g.copyStaticFiles(); err != nil {
		return fmt.Errorf("failed to copy static files: %w", err)
	}
	
	// 创建 keys 目录和文档
	if err := g.createKeysDirectory(); err != nil {
		return fmt.Errorf("failed to create keys directory: %w", err)
	}
	
	// 创建其他必要目录
	if err := g.createRequiredDirectories(); err != nil {
		return fmt.Errorf("failed to create required directories: %w", err)
	}
	
	return nil
}

// generateGoAccessConfig 生成 GoAccess 配置文件
func (g *GeneratorService) generateGoAccessConfig() error {
	goAccessConfig := `time-format %T
date-format %d/%b/%Y
log_format %h - %^ [%d:%t %^]  %s "%r" %b "%R" "%u" "%^"
geoip-database /data/GeoLite2-City.mmdb`
	
	filePath := filepath.Join(g.outputDir, "goaccess.conf")
	if err := os.WriteFile(filePath, []byte(goAccessConfig), 0644); err != nil {
		return fmt.Errorf("failed to write goaccess.conf: %w", err)
	}
	
	return nil
}

// copyStaticFiles 复制静态资源文件
func (g *GeneratorService) copyStaticFiles() error {
	staticDir := filepath.Join(g.outputDir, "static")
	if err := os.MkdirAll(staticDir, 0755); err != nil {
		return fmt.Errorf("failed to create static directory: %w", err)
	}
	
	// 检查源静态文件目录是否存在
	srcStaticDir := "./static"
	if _, err := os.Stat(srcStaticDir); err == nil {
		// 复制静态文件
		if err := g.copyDir(srcStaticDir, staticDir); err != nil {
			return fmt.Errorf("failed to copy static files: %w", err)
		}
	} else {
		// 创建基本的静态文件占位
		robotsContent := `User-agent: *
Allow: /

Sitemap: https://example.com/sitemap.xml`
		
		robotsPath := filepath.Join(staticDir, "robots.txt")
		if err := os.WriteFile(robotsPath, []byte(robotsContent), 0644); err != nil {
			return fmt.Errorf("failed to create robots.txt: %w", err)
		}
	}
	
	return nil
}

// createKeysDirectory 创建 keys 目录和相关文档
func (g *GeneratorService) createKeysDirectory() error {
	keysDir := filepath.Join(g.outputDir, "keys")
	if err := os.MkdirAll(keysDir, 0755); err != nil {
		return fmt.Errorf("failed to create keys directory: %w", err)
	}
	
	// 检查源 keys 目录是否有 README.md
	srcKeysReadme := "./keys/README.md"
	if _, err := os.Stat(srcKeysReadme); err == nil {
		destKeysReadme := filepath.Join(keysDir, "README.md")
		if err := g.copyFile(srcKeysReadme, destKeysReadme); err != nil {
			return fmt.Errorf("failed to copy keys README.md: %w", err)
		}
	} else {
		// 创建基本的 keys 说明文档
		keysReadmeContent := `# JWT Key Management

This directory contains JWT signing keys for the application.

## Setup Instructions

1. Generate Ed25519 key for JWT signing:
   ` + "```bash" + `
   openssl genpkey -algorithm Ed25519 -out jwt-ed25519.pem
   chmod 600 jwt-ed25519.pem
   ` + "```" + `

2. Or generate RSA key (alternative):
   ` + "```bash" + `
   openssl genrsa -out jwt-rsa.pem 3072
   chmod 600 jwt-rsa.pem
   ` + "```" + `

## Security Notes

- Never commit private keys to version control
- Set proper file permissions (600) for private keys
- Use different keys for different environments`
		
		readmePath := filepath.Join(keysDir, "README.md")
		if err := os.WriteFile(readmePath, []byte(keysReadmeContent), 0644); err != nil {
			return fmt.Errorf("failed to create keys README.md: %w", err)
		}
	}
	
	return nil
}

// createRequiredDirectories 创建其他必要目录
func (g *GeneratorService) createRequiredDirectories() error {
	// 创建 manage_static 目录
	manageStaticDir := filepath.Join(g.outputDir, "manage_static")
	if err := os.MkdirAll(manageStaticDir, 0755); err != nil {
		return fmt.Errorf("failed to create manage_static directory: %w", err)
	}
	
	// 创建 .gitkeep 文件
	gitkeepPath := filepath.Join(manageStaticDir, ".gitkeep")
	if err := os.WriteFile(gitkeepPath, []byte{}, 0644); err != nil {
		return fmt.Errorf("failed to create .gitkeep: %w", err)
	}
	
	// 创建 geoip 目录
	geoipDir := filepath.Join(g.outputDir, "geoip")
	if err := os.MkdirAll(geoipDir, 0755); err != nil {
		return fmt.Errorf("failed to create geoip directory: %w", err)
	}
	
	// 检查源 geoip 文件是否存在
	srcGeoipFile := "./geoip/Country.mmdb"
	destGeoipFile := filepath.Join(geoipDir, "Country.mmdb")
	if _, err := os.Stat(srcGeoipFile); err == nil {
		// 复制 GeoIP 数据库文件
		if err := g.copyFile(srcGeoipFile, destGeoipFile); err != nil {
			return fmt.Errorf("failed to copy GeoIP database: %w", err)
		}
	} else {
		// 创建占位文件
		gitkeepGeoipPath := filepath.Join(geoipDir, ".gitkeep")
		if err := os.WriteFile(gitkeepGeoipPath, []byte{}, 0644); err != nil {
			return fmt.Errorf("failed to create geoip .gitkeep: %w", err)
		}
	}
	
	return nil
}