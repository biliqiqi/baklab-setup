package services

import (
	"crypto/ed25519"
	"crypto/rand"
	"crypto/x509"
	"encoding/json"
	"encoding/pem"
	"fmt"
	"io/fs"
	"log"
	"os"
	"path/filepath"
	"strings"
	"text/template"
	"time"

	"github.com/biliqiqi/baklab-setup/internal/model"
	"github.com/biliqiqi/baklab-setup/internal/utils"
)

type GeneratorService struct {
	outputDir   string
	templatesFS fs.FS
}

func (g *GeneratorService) buildOAuthProviders(oauth model.OAuthConfig) string {
	var providers []string
	if oauth.GoogleEnabled && oauth.GoogleClientID != "" && oauth.GoogleSecret != "" {
		providers = append(providers, "google")
	}
	if oauth.GithubEnabled && oauth.GithubClientID != "" && oauth.GithubSecret != "" {
		providers = append(providers, "github")
	}
	return strings.Join(providers, ",")
}

func NewGeneratorService() *GeneratorService {
	return &GeneratorService{
		outputDir: "./output",
	}
}

func (g *GeneratorService) SetOutputDir(dir string) {
	g.outputDir = dir
}

func (g *GeneratorService) SetTemplatesFS(templatesFS fs.FS) {
	g.templatesFS = templatesFS
}

func (g *GeneratorService) GetAbsoluteOutputDir() (string, error) {
	absPath, err := filepath.Abs(g.outputDir)
	if err != nil {
		return "", fmt.Errorf("failed to get absolute path for output directory: %w", err)
	}
	return absPath, nil
}

func (g *GeneratorService) ClearOutputDir() error {
	if _, err := os.Stat(g.outputDir); os.IsNotExist(err) {
		return nil
	}

	entries, err := os.ReadDir(g.outputDir)
	if err != nil {
		return fmt.Errorf("failed to read output directory: %w", err)
	}

	for _, entry := range entries {
		entryPath := filepath.Join(g.outputDir, entry.Name())

		if entry.Name() == "nginx" {
			if err := g.clearNginxDir(entryPath); err != nil {
				return fmt.Errorf("failed to clear nginx directory: %w", err)
			}
			continue
		}

		if entry.Name() == "ssl" {
			log.Printf("Preserving existing SSL directory: %s", entryPath)
			continue
		}

		if entry.Name() == "frontend_dist" {
			if err := g.clearFrontendDistDir(entryPath); err != nil {
				return fmt.Errorf("failed to clear frontend_dist directory: %w", err)
			}
			continue
		}

		if err := os.RemoveAll(entryPath); err != nil {
			return fmt.Errorf("failed to remove %s: %w", entryPath, err)
		}
	}

	return nil
}

func (g *GeneratorService) clearNginxDir(nginxPath string) error {
	entries, err := os.ReadDir(nginxPath)
	if err != nil {
		if os.IsNotExist(err) {
			return nil
		}
		return err
	}

	for _, entry := range entries {
		entryPath := filepath.Join(nginxPath, entry.Name())

		if entry.Name() == "logs" {
			log.Printf("Skipping nginx/logs directory to avoid permission issues")
			continue
		}

		if err := os.RemoveAll(entryPath); err != nil {
			return fmt.Errorf("failed to remove %s: %w", entryPath, err)
		}
	}

	return nil
}

func (g *GeneratorService) clearFrontendDistDir(frontendDistPath string) error {
	if _, err := os.Stat(frontendDistPath); os.IsNotExist(err) {
		return nil
	}

	log.Printf("Clearing frontend_dist directory with permission fixes: %s", frontendDistPath)

	err := filepath.Walk(frontendDistPath, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			log.Printf("Warning: failed to access %s during permission walk: %v", path, err)
			return nil
		}

		var perm os.FileMode
		if info.IsDir() {
			perm = 0755
		} else {
			perm = 0644
		}

		if err := os.Chmod(path, perm); err != nil {
			log.Printf("Warning: failed to change permissions for %s: %v", path, err)
		}
		return nil
	})

	if err != nil {
		log.Printf("Warning: failed to walk frontend_dist directory: %v", err)
	}

	if err := os.RemoveAll(frontendDistPath); err != nil {
		log.Printf("Warning: failed to remove frontend_dist after permission fix: %v", err)
		entries, readErr := os.ReadDir(frontendDistPath)
		if readErr == nil {
			for _, entry := range entries {
				entryPath := filepath.Join(frontendDistPath, entry.Name())
				if removeErr := os.RemoveAll(entryPath); removeErr != nil {
					log.Printf("Warning: failed to remove %s: %v", entryPath, removeErr)
				}
			}
		}
		return err
	}

	log.Printf("Successfully cleared frontend_dist directory")
	return nil
}

func (g *GeneratorService) GenerateEnvFile(cfg *model.SetupConfig) error {
	if err := os.MkdirAll(g.outputDir, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	dataDir := filepath.Join("./data")
	if err := os.MkdirAll(dataDir, 0755); err != nil {
		return fmt.Errorf("failed to create data directory: %w", err)
	}

	logsDir := filepath.Join("./data/logs")
	if err := os.MkdirAll(logsDir, 0755); err != nil {
		return fmt.Errorf("failed to create logs directory: %w", err)
	}

	envTemplate := `# Generated by baklab setup service
# Generated at: {{ .Timestamp }}

# Language Configuration
DEFAULT_LANG={{ .App.DefaultLang }}

# Database Configuration
DB_HOST='{{ .Database.Host }}'
DB_PORT={{ .Database.Port }}
PG_USER='{{ .Database.SuperUser }}'
PG_PASSWORD='{{ .Database.SuperPassword }}'
APP_DB_NAME='{{ .Database.Name }}'
APP_DB_USER='{{ .Database.AppUser }}'
APP_DB_PASSWORD='{{ .Database.AppPassword }}'

# Redis Configuration
REDIS_HOST='{{ .Redis.Host }}'
REDIS_PORT={{ .Redis.Port }}
REDIS_USER='{{ .Redis.User }}'
REDIS_PASSWORD='{{ .Redis.Password }}'
REDISCLI_AUTH='{{ .Redis.AdminPassword }}'

# Application Configuration
SERVER_DOMAIN_NAME='{{ .App.DomainName }}'
ROOT_DOMAIN_NAME='{{ rootDomain .App.DomainName }}'
BRAND_NAME='{{ .App.BrandName }}'
DEBUG={{ .App.Debug }}
TEST=false
APP_VERSION={{ if .App.Version }}{{ .App.Version }}{{ else }}latest{{ end }}

# Go Runtime Configuration
GOMAXPROCS=1

# HTTPS Configuration
# Set to true when using HTTPS (nginx SSL configuration)
USE_HTTPS={{ .SSL.Enabled }}

JWT_KEY_FILE=./keys/jwt-private.pem

# Application Ports
APP_PORT=3000
APP_OUTER_PORT=3000
{{ if .OAuth.FrontendOrigin }}FRONTEND_ORIGIN='{{ .OAuth.FrontendOrigin }}'{{ else }}FRONTEND_ORIGIN='http{{ if .SSL.Enabled }}s{{ end }}://{{ .App.DomainName }}'{{ end }}
NGINX_PORT=80
NGINX_SSL_PORT=443

# Network Configuration
{{ if .CORSOrigins }}CORS_ALLOW_ORIGINS='{{ .CORSOrigins }}'{{ else }}CORS_ALLOW_ORIGINS='http{{ if ne .App.DomainName "localhost" }}s{{ end }}://{{ .App.DomainName }}'{{ end }}

# Frontend Configuration
{{ if .App.SSREnabled }}FRONTEND_CONTAINER_ID='{{ .App.FrontendContainerId }}'{{ else }}FRONTEND_CONTAINER_ID=root{{ end }}
{{ if .App.SSREnabled }}FRONTEND_SCRIPTS='{{ join .App.FrontendScripts "," }}'{{ else }}FRONTEND_SCRIPTS={{ end }}
{{ if .App.SSREnabled }}FRONTEND_STYLES='{{ join .App.FrontendStyles "," }}'{{ else }}FRONTEND_STYLES={{ end }}

# Service Configuration
STATIC_HOST_NAME='{{ .App.StaticHostName }}'
RANKING_HOST_NAME=''

# OAuth Configuration (optional)
{{ if .OAuth.GoogleClientID }}GOOGLE_CLIENT_ID='{{ .OAuth.GoogleClientID }}'{{ else }}GOOGLE_CLIENT_ID={{ end }}
{{ if .OAuth.GoogleSecret }}GOOGLE_CLIENT_SECRET='{{ .OAuth.GoogleSecret }}'{{ else }}GOOGLE_CLIENT_SECRET={{ end }}
{{ if .OAuth.GithubClientID }}GITHUB_CLIENT_ID='{{ .OAuth.GithubClientID }}'{{ else }}GITHUB_CLIENT_ID={{ end }}
{{ if .OAuth.GithubSecret }}GITHUB_CLIENT_SECRET='{{ .OAuth.GithubSecret }}'{{ else }}GITHUB_CLIENT_SECRET={{ end }}

# Cloudflare Configuration (optional)
{{ if .App.CloudflareSiteKey }}CLOUDFLARE_SITE_KEY='{{ .App.CloudflareSiteKey }}'{{ else }}CLOUDFLARE_SITE_KEY={{ end }}
{{ if .App.CloudflareSecret }}CLOUDFLARE_SECRET='{{ .App.CloudflareSecret }}'{{ else }}CLOUDFLARE_SECRET={{ end }}

# SMTP Configuration (optional)
{{ if .SMTP.Server }}SMTP_SERVER='{{ .SMTP.Server }}'{{ else }}SMTP_SERVER={{ end }}
SMTP_SERVER_PORT={{ if .SMTP.Port }}{{ .SMTP.Port }}{{ else }}587{{ end }}
{{ if .SMTP.User }}SMTP_USER='{{ .SMTP.User }}'{{ else }}SMTP_USER={{ end }}
{{ if .SMTP.Password }}SMTP_PASSWORD='{{ .SMTP.Password }}'{{ else }}SMTP_PASSWORD={{ end }}
{{ if .SMTP.Sender }}SMTP_SENDER='{{ .SMTP.Sender }}'{{ else }}SMTP_SENDER='noreply@{{ .App.DomainName }}'{{ end }}

# Super User Configuration (Initial Admin User)
SUPER_USER='{{ .AdminUser.Username }}'
SUPER_PASSWORD='{{ .AdminUser.Password }}'
SUPER_USER_EMAIL='{{ .AdminUser.Email }}'

# SMS Configuration (optional)
SMS_PROVIDER=
SMS_ENDPOINT=
SMS_API_KEY=
SMS_API_SECRET=
SMS_SIGN_NAME=
SMS_TEMPLATE_REGISTER=
SMS_TEMPLATE_RESET=
SMS_FROM=

# File Paths
{{ if hasGeoFile .SetupConfig }}GEOIP_ENABLED=true
GEOIP_FILE=./geoip/GeoLite2-City.mmdb{{ else }}GEOIP_ENABLED=false
GEOIP_FILE=./geoip/Country.mmdb{{ end }}
I18N_FILE_DIR=./i18n
MIGRATION_FILE_DIR=./config/db/migrations
DEFAULT_DATA_DIR=./config/defaults

# Development Configuration
HOST_PROXY=
APP_LOCAL_HOST=172.17.0.1

# Setup Status
SETUP_COMPLETED=true
SETUP_COMPLETED_AT={{ .Timestamp }}

# User Configuration (for Docker permissions)
UID={{ .UserID }}
GID={{ .GroupID }}
`

	funcMap := template.FuncMap{
		"rootDomain": func(domain string) string {
			domain = strings.TrimSuffix(domain, ".")

			if domain == "" {
				return domain
			}

			parts := strings.Split(domain, ".")

			if len(parts) < 2 {
				return domain
			}

			return strings.Join(parts[len(parts)-2:], ".")
		},
		"join": func(slice []string, sep string) string {
			return strings.Join(slice, sep)
		},
		"oauthProviders": g.buildOAuthProviders,
		"hasGeoFile": func(cfg *model.SetupConfig) bool {
			return cfg.HasGeoFile()
		},
	}

	tmpl, err := template.New("env").Funcs(funcMap).Parse(envTemplate)
	if err != nil {
		return fmt.Errorf("failed to parse env template: %w", err)
	}

	corsOrigins := ""
	if len(cfg.App.CORSAllowOrigins) > 0 {
		corsOrigins = strings.Join(cfg.App.CORSAllowOrigins, ",")
	}

	data := struct {
		*model.SetupConfig
		Timestamp   string
		CORSOrigins string
		UserID      string
		GroupID     string
	}{
		SetupConfig: cfg,
		Timestamp:   time.Now().Format(time.RFC3339),
		CORSOrigins: corsOrigins,
		UserID:      fmt.Sprintf("%d", os.Getuid()),
		GroupID:     fmt.Sprintf("%d", os.Getgid()),
	}

	filePath := filepath.Join(g.outputDir, ".env.production")
	file, err := os.Create(filePath)
	if err != nil {
		return fmt.Errorf("failed to create env file: %w", err)
	}
	defer func() {
		if err := file.Close(); err != nil {
			log.Printf("Warning: failed to close env file: %v", err)
		}
	}()

	if err := tmpl.Execute(file, data); err != nil {
		return fmt.Errorf("failed to execute env template: %w", err)
	}

	return nil
}

func (g *GeneratorService) handleSSLCertificates(cfg *model.SetupConfig) error {
	if !cfg.SSL.Enabled {
		return nil
	}

	// Create ssl directory in output
	sslDir := filepath.Join(g.outputDir, "ssl")
	if err := os.MkdirAll(sslDir, 0755); err != nil {
		return fmt.Errorf("failed to create ssl directory: %w", err)
	}

	// Check if certificate files exist
	if _, err := os.Stat(cfg.SSL.CertPath); err != nil {
		return fmt.Errorf("certificate file not found at %s: %w", cfg.SSL.CertPath, err)
	}
	if _, err := os.Stat(cfg.SSL.KeyPath); err != nil {
		return fmt.Errorf("key file not found at %s: %w", cfg.SSL.KeyPath, err)
	}

	// Copy certificate files to output/ssl
	certDest := filepath.Join(sslDir, "fullchain.pem")
	keyDest := filepath.Join(sslDir, "privkey.pem")

	if err := copyFile(cfg.SSL.CertPath, certDest); err != nil {
		return fmt.Errorf("failed to copy certificate: %w", err)
	}
	if err := copyFile(cfg.SSL.KeyPath, keyDest); err != nil {
		return fmt.Errorf("failed to copy key: %w", err)
	}

	log.Printf("Copied SSL certificates to output/ssl/")

	// Get absolute path of output directory
	absOutputDir, err := filepath.Abs(g.outputDir)
	if err != nil {
		return fmt.Errorf("failed to get absolute output path: %w", err)
	}

	// Update config to use absolute paths
	cfg.SSL.CertPath = filepath.Join(absOutputDir, "ssl", "fullchain.pem")
	cfg.SSL.KeyPath = filepath.Join(absOutputDir, "ssl", "privkey.pem")

	log.Printf("Updated SSL paths to absolute:")
	log.Printf("  Cert: %s", cfg.SSL.CertPath)
	log.Printf("  Key:  %s", cfg.SSL.KeyPath)

	return nil
}

func (g *GeneratorService) GenerateDockerConfig(cfg *model.SetupConfig) error {
	// Handle SSL certificates - copy to output and update paths to absolute
	if cfg.SSL.Enabled {
		if err := g.handleSSLCertificates(cfg); err != nil {
			return fmt.Errorf("failed to handle SSL certificates: %w", err)
		}
	}

	if err := g.copyTemplateFiles(cfg); err != nil {
		return fmt.Errorf("failed to copy template files: %w", err)
	}
	dockerComposeTemplate := `# Generated by baklab setup service
# Production Docker Compose Configuration

services:
  static-initializer:
    image: ghcr.io/biliqiqi/baklab:$APP_VERSION
    container_name: "baklab-static-init"
    volumes:
      - ./frontend_dist:/frontend:ro
      - static-data:/static-output
    command: >
      sh -c "
        echo 'Initializing static files from app image...' &&
        cp -r /app/static/* /static-output/ &&
        if [ -f /frontend/manifest.webmanifest ]; then
          echo 'Copying PWA manifest to static directory...' &&
          cp /frontend/manifest.webmanifest /static-output/site.webmanifest &&
          chmod 644 /static-output/site.webmanifest &&
          echo 'PWA manifest copied successfully'
        fi &&
        echo 'Static files initialization completed'
      "
    depends_on:
      frontend-builder:
        condition: service_completed_successfully
    restart: "no"

  db-migrator:
    image: ghcr.io/biliqiqi/baklab:$APP_VERSION
    container_name: "baklab-db-migrator"
    environment:
      {{- if eq .Database.ServiceType "docker" }}
      DB_HOST: "db"
      DB_PORT: 5432
      {{- else }}
      DB_HOST: "{{.Database.Host}}"
      DB_PORT: {{.Database.Port}}
      {{- end }}
      PG_USER: $PG_USER
      PG_PASSWORD: $PG_PASSWORD
      APP_DB_NAME: $APP_DB_NAME
      MIGRATION_FILE_DIR: $MIGRATION_FILE_DIR
    command: ["./baklab", "migrate"]
    depends_on:
      {{- if eq .Database.ServiceType "docker" }}
      db:
        condition: service_healthy
      {{- end }}
    restart: "no"

  app:
    image: ghcr.io/biliqiqi/baklab:$APP_VERSION
    container_name: "baklab-app"
    restart: on-failure:5
    environment:
      {{- if eq .Database.ServiceType "docker" }}
      DB_CONTAINER_NAME: "baklab-db"
      DB_HOST: "db"
      DB_PORT: 5432
      {{- else }}
      DB_HOST: "{{.Database.Host}}"
      DB_PORT: {{.Database.Port}}
      {{- end }}
      SERVER_DOMAIN_NAME: $SERVER_DOMAIN_NAME
      APP_DB_NAME: $APP_DB_NAME
      APP_DB_USER: $APP_DB_USER
      APP_DB_PASSWORD: $APP_DB_PASSWORD
      APP_PORT: $APP_PORT
      APP_OUTER_PORT: $APP_OUTER_PORT
      NGINX_PORT: $NGINX_PORT
      NGINX_SSL_PORT: $NGINX_SSL_PORT
      {{- if eq .Redis.ServiceType "docker" }}
      REDIS_HOST: "redis"
      REDIS_PORT: 6379
      {{- else }}
      REDIS_HOST: "{{.Redis.Host}}"
      REDIS_PORT: {{.Redis.Port}}
      {{- end }}
      REDIS_USER: $REDIS_USER
      REDIS_PASSWORD: $REDIS_PASSWORD
      REDISCLI_AUTH: $REDISCLI_AUTH
      SMTP_SERVER: $SMTP_SERVER
      SMTP_SERVER_PORT: $SMTP_SERVER_PORT
      SMTP_USER: $SMTP_USER
      SMTP_PASSWORD: $SMTP_PASSWORD
      SMTP_SENDER: $SMTP_SENDER
      GOOGLE_CLIENT_ID: $GOOGLE_CLIENT_ID
      GOOGLE_CLIENT_SECRET: $GOOGLE_CLIENT_SECRET
      GITHUB_CLIENT_ID: $GITHUB_CLIENT_ID
      GITHUB_CLIENT_SECRET: $GITHUB_CLIENT_SECRET
      APP_VERSION: $APP_VERSION
      CLOUDFLARE_SITE_KEY: $CLOUDFLARE_SITE_KEY
      CLOUDFLARE_SECRET: $CLOUDFLARE_SECRET
      JWT_KEY_FILE: $JWT_KEY_FILE
      STATIC_HOST_NAME: $STATIC_HOST_NAME
      RANKING_HOST_NAME: $RANKING_HOST_NAME
      CORS_ALLOW_ORIGINS: $CORS_ALLOW_ORIGINS
      FRONTEND_CONTAINER_ID: $FRONTEND_CONTAINER_ID
      GEOIP_ENABLED: $GEOIP_ENABLED
      GEOIP_FILE: $GEOIP_FILE
      I18N_FILE_DIR: $I18N_FILE_DIR
      MIGRATION_FILE_DIR: $MIGRATION_FILE_DIR
      DEFAULT_DATA_DIR: $DEFAULT_DATA_DIR
      DEFAULT_LANG: $DEFAULT_LANG
      BRAND_NAME: $BRAND_NAME
      DEBUG: $DEBUG
      TEST: $TEST
      SUPER_USER: $SUPER_USER
      SUPER_PASSWORD: $SUPER_PASSWORD
      SUPER_USER_EMAIL: $SUPER_USER_EMAIL
      USE_HTTPS: $USE_HTTPS
      FRONTEND_ORIGIN: $FRONTEND_ORIGIN
      GOMAXPROCS: $GOMAXPROCS
    volumes:
      {{ if .App.JWTKeyFromFile -}}
      - {{ .App.JWTKeyFilePath }}:/app/keys/jwt-private.pem
      {{- else -}}
      - ./keys:/app/keys
      {{- end }}
      - ./frontend_dist:/frontend:ro
      - ./manage_static:/app/manage_static:ro{{ if hasGeoFile . }}
      - ./geoip:/app/geoip:ro{{ end }}
    command: >
      sh -c "
        if [ -f /frontend/.frontend-manifest.json ]; then
          echo 'Loading frontend configuration from manifest...' &&
          FRONTEND_SCRIPTS=$$(cat /frontend/.frontend-manifest.json | grep -o '\"scripts\":[[:space:]]*\"[^\"]*\"' | cut -d'\"' -f4) &&
          FRONTEND_STYLES=$$(cat /frontend/.frontend-manifest.json | grep -o '\"styles\":[[:space:]]*\"[^\"]*\"' | cut -d'\"' -f4) &&
          export FRONTEND_SCRIPTS &&
          export FRONTEND_STYLES &&
          echo \"Loaded: FRONTEND_SCRIPTS=$$FRONTEND_SCRIPTS\" &&
          echo \"Loaded: FRONTEND_STYLES=$$FRONTEND_STYLES\"
        else
          echo 'Frontend manifest not found, using defaults' &&
          export FRONTEND_SCRIPTS='' &&
          export FRONTEND_STYLES=''
        fi &&
        echo 'Starting baklab with entrypoint script...' &&
        ./docker-entrypoint.sh
      "
    depends_on:
      static-initializer:
        condition: service_completed_successfully
      db-migrator:
        condition: service_completed_successfully
      {{- if eq .Database.ServiceType "docker" }}
      db:
        condition: service_healthy
      {{- end }}
      {{- if eq .Redis.ServiceType "docker" }}
      redis:
        condition: service_healthy
      {{- end }}
    {{- if or (eq .Database.ServiceType "docker") (eq .Redis.ServiceType "docker") }}
    links:
      {{- if eq .Database.ServiceType "docker" }}
      - db
      {{- end }}
      {{- if eq .Redis.ServiceType "docker" }}
      - redis
      {{- end }}
    {{- end }}
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:$APP_PORT/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 30s
{{ if eq .Database.ServiceType "docker" }}

  db:
    build:
      context: .
      dockerfile: ./Dockerfile.pg
    container_name: "baklab-db"
    restart: always
    volumes:
      - db-data:/var/lib/postgresql/data
      - ./db/initdb:/docker-entrypoint-initdb.d/
      - ./db/postgresql.conf:/etc/postgresql/custom/postgresql.conf
    command:
      - postgres
      - -c
      - config_file=/etc/postgresql/custom/postgresql.conf
    environment:
      - POSTGRES_USER=${PG_USER}
      - POSTGRES_DB=postgres
      - POSTGRES_PASSWORD=${PG_PASSWORD}
      - APP_DB_NAME=${APP_DB_NAME}
      - APP_DB_USER=${APP_DB_USER}
      - APP_DB_PASSWORD=${APP_DB_PASSWORD}
      - PGTZ=UTC
      - DEBUG=${DEBUG:-false}
    ports:
      - ${DB_PORT}:5432
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${PG_USER} -d postgres"]
      interval: 10s
      timeout: 5s
      retries: 5
{{ end }}
{{ if eq .Redis.ServiceType "docker" }}
  redis-acl-generator:
    image: alpine:latest
    container_name: "baklab-redis-acl-gen"
    environment:
      - REDIS_USER=${REDIS_USER}
      - REDIS_PASSWORD=${REDIS_PASSWORD}
      - REDISCLI_AUTH=${REDISCLI_AUTH}
    volumes:
      - ./redis:/src:ro
      - redis-config:/config
    command: |
      sh -c '
        cp /src/redis.conf /config/
        echo "user default +@all ~* on >$$REDISCLI_AUTH" > /config/users.acl
        echo "user $$REDIS_USER +@read +@write +@list +@hash +@set +@string +@connection +scan +del +exists +type +ttl +expire ~* -@admin -@dangerous on >$$REDIS_PASSWORD" >> /config/users.acl
        echo "ACL file generated successfully"
        echo "Users configured: default (admin access), $$REDIS_USER (app access)"
        echo "ACL file location: /config/users.acl"
      '

  redis:
    image: valkey/valkey:7.2-alpine
    container_name: "baklab-redis"
    depends_on:
      redis-acl-generator:
        condition: service_completed_successfully
    environment:
      - REDIS_USER=${REDIS_USER}
      - REDIS_PASSWORD=${REDIS_PASSWORD}
      - REDISCLI_AUTH=${REDISCLI_AUTH}
    volumes:
      - redis-data:/data
      - ./redis/redis.conf:/usr/local/etc/redis/redis.conf:ro
      - redis-config:/usr/local/etc/redis
    command: valkey-server /usr/local/etc/redis/redis.conf
    ports:
      - ${REDIS_PORT}:6379
    healthcheck:
      test: ["CMD", "valkey-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5
{{ end }}
  frontend-builder:
    image: ghcr.io/biliqiqi/baklab-web:latest
    container_name: "baklab-frontend-builder"
    user: "${UID:-1000}:${GID:-1000}"
    environment:
      {{- if .SSL.Enabled }}
      - STATIC_HOST=https://$STATIC_HOST_NAME
      - API_HOST=https://$SERVER_DOMAIN_NAME
      - FRONTEND_HOST=https://$SERVER_DOMAIN_NAME
      {{- else }}
      - STATIC_HOST=http://$STATIC_HOST_NAME
      - API_HOST=http://$SERVER_DOMAIN_NAME
      - FRONTEND_HOST=http://$SERVER_DOMAIN_NAME
      {{- end }}
      - BASE_URL=/static/frontend/
      - API_PATH_PREFIX=/api/
      - OAUTH_PROVIDERS={{ oauthProviders .OAuth }}
      - BRAND_NAME=$BRAND_NAME
    volumes:
      - ./frontend_dist:/output
    restart: "no"
  nginx:
    image: nginx:1.25.2-alpine
    container_name: "baklab-nginx"
    restart: always
    environment:
      - APP_LOCAL_HOST=app
      - APP_PORT=$APP_PORT
      - ROOT_DOMAIN_NAME=$ROOT_DOMAIN_NAME
    volumes:
      - static-data:/data/static
      - ./frontend_dist:/data/static/frontend:ro
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
      - ./nginx/templates/baklab.conf.template:/etc/nginx/templates/baklab.conf.template:ro
      - ./nginx/logs:/etc/nginx/logs{{if .SSL.Enabled}}
      - {{.SSL.CertPath}}:/etc/ssl/certs/server.crt:ro
      - {{.SSL.KeyPath}}:/etc/ssl/private/server.key:ro{{end}}
    ports:{{if .SSL.Enabled}}
      - $NGINX_SSL_PORT:443{{end}}
      - $NGINX_PORT:80
    depends_on:
      app:
        condition: service_healthy
    healthcheck:
      test: ["CMD-SHELL", "curl -H 'Host: $ROOT_DOMAIN_NAME' -f http://localhost:80/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 10s{{ if .GoAccess.Enabled }}
  goaccess:
    image: allinurl/goaccess:1.7.2
    container_name: "baklab-goaccess"
    restart: always{{if .SSL.Enabled}}
    entrypoint: 'sh -c "/bin/goaccess /data/logs/access.log -o /data/static/report.html --real-time-html --port=9880 --ssl-cert=$$SSL_CERT --ssl-key=$$SSL_KEY"'
    environment:
      - TZ="China/Shanghai"
      - SSL_CERT=/etc/ssl/certs/server.crt
      - SSL_KEY=/etc/ssl/private/server.key{{else}}
    entrypoint: 'sh -c "/bin/goaccess /data/logs/access.log -o /data/static/report.html --real-time-html --port=9880"'
    environment:
      - TZ="China/Shanghai"{{end}}
    volumes:
      - /var/www/goaccess:/var/www/goaccess:rw{{ if .GoAccess.HasGeoFile }}
      - ./geoip:/data/geoip:ro{{ end }}{{if .SSL.Enabled}}
      - {{.SSL.CertPath}}:/etc/ssl/certs/server.crt:ro
      - {{.SSL.KeyPath}}:/etc/ssl/private/server.key:ro{{end}}
      - ./goaccess.conf:/etc/goaccess/goaccess.conf
      - ./nginx/logs:/data/logs
      - ./manage_static:/data/static
    ports:
      - "9880:9880"
    depends_on:
      nginx:
        condition: service_healthy{{ end }}
  dali:
    image: ghcr.io/biliqiqi/dali-web:latest
    container_name: "baklab-dali"
    restart: always
    environment:
      - STATIC_HOST={{ if .SSL.Enabled }}https{{ else }}http{{ end }}://$STATIC_HOST_NAME
      - API_HOST={{ if .SSL.Enabled }}https{{ else }}http{{ end }}://$SERVER_DOMAIN_NAME
      - API_PATH_PREFIX=
      - BAKLAB_WEB_HOST={{ if .SSL.Enabled }}https{{ else }}http{{ end }}://$SERVER_DOMAIN_NAME
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:80"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 10s

volumes:
  static-data:{{ if eq .Database.ServiceType "docker" }}
  db-data:{{ end }}{{ if eq .Redis.ServiceType "docker" }}
  redis-data:
  redis-config:{{ end }}
`

	dockerFuncMap := template.FuncMap{
		"oauthProviders": g.buildOAuthProviders,
		"hasGeoFile": func(cfg *model.SetupConfig) bool {
			return cfg.HasGeoFile()
		},
	}

	tmpl, err := template.New("docker").Funcs(dockerFuncMap).Parse(dockerComposeTemplate)
	if err != nil {
		return fmt.Errorf("failed to parse docker template: %w", err)
	}

	filePath := filepath.Join(g.outputDir, "docker-compose.production.yml")
	file, err := os.Create(filePath)
	if err != nil {
		return fmt.Errorf("failed to create docker compose file: %w", err)
	}
	defer func() {
		if err := file.Close(); err != nil {
			log.Printf("Warning: failed to close docker compose file: %v", err)
		}
	}()

	if err := tmpl.Execute(file, cfg); err != nil {
		return fmt.Errorf("failed to execute docker template: %w", err)
	}

	if cfg.Redis.ServiceType == "docker" {
		if err := g.generateRedisConfig(cfg); err != nil {
			return fmt.Errorf("failed to generate redis config: %w", err)
		}
	}

	if err := g.GenerateNginxConfig(cfg); err != nil {
		return fmt.Errorf("failed to generate nginx config: %w", err)
	}

	if err := g.generateAdditionalConfigs(cfg); err != nil {
		return fmt.Errorf("failed to generate additional configs: %w", err)
	}

	return nil
}

func (g *GeneratorService) copyTemplateFiles(cfg *model.SetupConfig) error {
	if cfg.Database.ServiceType == "docker" {
		dbDir := filepath.Join(g.outputDir, "db")
		if err := os.MkdirAll(dbDir, 0755); err != nil {
			return fmt.Errorf("failed to create db directory: %w", err)
		}

		destInitdbDir := filepath.Join(dbDir, "initdb")
		if err := g.copyDirFromFS("db/initdb", destInitdbDir); err != nil {
			return fmt.Errorf("failed to copy initdb directory: %w", err)
		}

		destPostgresqlConf := filepath.Join(dbDir, "postgresql.conf")
		if err := g.copyFileFromFS("db/postgresql.conf", destPostgresqlConf); err != nil {
			return fmt.Errorf("failed to copy postgresql.conf: %w", err)
		}

		destDockerfile := filepath.Join(g.outputDir, "Dockerfile.pg")
		if err := g.copyFileFromFS("db/Dockerfile.pg", destDockerfile); err != nil {
			return fmt.Errorf("failed to copy Dockerfile.pg: %w", err)
		}
	}

	return nil
}

func (g *GeneratorService) copyFile(src, dest string) error {
	sourceFile, err := os.Open(src)
	if err != nil {
		return err
	}
	defer utils.Close(sourceFile, "source file: "+src)

	destFile, err := os.Create(dest)
	if err != nil {
		return err
	}
	defer utils.Close(destFile, "dest file: "+dest)

	_, err = destFile.ReadFrom(sourceFile)
	return err
}

func (g *GeneratorService) copyFileFromFS(src, dest string) error {
	content, err := fs.ReadFile(g.templatesFS, src)
	if err != nil {
		return fmt.Errorf("failed to read from embedded FS: %w", err)
	}

	if err := os.WriteFile(dest, content, 0644); err != nil {
		return fmt.Errorf("failed to write file: %w", err)
	}

	return nil
}

func (g *GeneratorService) copyDirFromFS(src, dest string) error {
	if err := os.MkdirAll(dest, 0755); err != nil {
		return fmt.Errorf("failed to create directory: %w", err)
	}

	entries, err := fs.ReadDir(g.templatesFS, src)
	if err != nil {
		return fmt.Errorf("failed to read embedded directory: %w", err)
	}

	for _, entry := range entries {
		srcPath := filepath.Join(src, entry.Name())
		destPath := filepath.Join(dest, entry.Name())

		if entry.IsDir() {
			if err := g.copyDirFromFS(srcPath, destPath); err != nil {
				return err
			}
		} else {
			if err := g.copyFileFromFS(srcPath, destPath); err != nil {
				return err
			}
		}
	}

	return nil
}

func (g *GeneratorService) generateRedisConfig(cfg *model.SetupConfig) error {
	redisDir := filepath.Join(g.outputDir, "redis")
	if err := os.MkdirAll(redisDir, 0755); err != nil {
		return fmt.Errorf("failed to create redis directory: %w", err)
	}

	redisConfContent, err := fs.ReadFile(g.templatesFS, "redis/redis.conf")
	if err != nil {
		return fmt.Errorf("failed to read redis.conf template: %w", err)
	}

	redisConfPath := filepath.Join(redisDir, "redis.conf")
	if err := os.WriteFile(redisConfPath, redisConfContent, 0644); err != nil {
		return fmt.Errorf("failed to write redis.conf: %w", err)
	}

	return nil
}

func (g *GeneratorService) GenerateNginxConfig(cfg *model.SetupConfig) error {
	nginxDir := filepath.Join(g.outputDir, "nginx")
	templatesDir := filepath.Join(nginxDir, "templates")
	if err := os.MkdirAll(templatesDir, 0755); err != nil {
		return fmt.Errorf("failed to create nginx directories: %w", err)
	}

	nginxConfContent, err := fs.ReadFile(g.templatesFS, "nginx/nginx.conf")
	if err != nil {
		return fmt.Errorf("failed to read nginx.conf template: %w", err)
	}

	nginxConfPath := filepath.Join(nginxDir, "nginx.conf")
	if err := os.WriteFile(nginxConfPath, nginxConfContent, 0644); err != nil {
		return fmt.Errorf("failed to write nginx.conf: %w", err)
	}

	baklabTemplateContent, err := fs.ReadFile(g.templatesFS, "nginx/baklab.conf.template")
	if err != nil {
		return fmt.Errorf("failed to read baklab.conf.template: %w", err)
	}

	tmpl, err := template.New("baklab").Parse(string(baklabTemplateContent))
	if err != nil {
		return fmt.Errorf("failed to parse baklab.conf template: %w", err)
	}

	baklabTemplatePath := filepath.Join(templatesDir, "baklab.conf.template")
	file, err := os.Create(baklabTemplatePath)
	if err != nil {
		return fmt.Errorf("failed to create baklab.conf.template file: %w", err)
	}
	defer func() {
		if err := file.Close(); err != nil {
			log.Printf("Warning: failed to close baklab.conf.template file: %v", err)
		}
	}()

	if err := tmpl.Execute(file, cfg); err != nil {
		return fmt.Errorf("failed to execute baklab.conf template: %w", err)
	}

	return nil
}

func (g *GeneratorService) GenerateJWTKey() ([]byte, error) {
	_, privateKey, err := ed25519.GenerateKey(rand.Reader)
	if err != nil {
		return nil, fmt.Errorf("failed to generate Ed25519 key: %w", err)
	}

	privateKeyBytes, err := x509.MarshalPKCS8PrivateKey(privateKey)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal private key: %w", err)
	}

	privateKeyPEM := pem.EncodeToMemory(&pem.Block{
		Type:  "PRIVATE KEY",
		Bytes: privateKeyBytes,
	})

	return privateKeyPEM, nil
}

func (g *GeneratorService) generateAdditionalConfigs(cfg *model.SetupConfig) error {
	if cfg.GoAccess.Enabled {
		if err := g.generateGoAccessConfig(); err != nil {
			return fmt.Errorf("failed to generate goaccess config: %w", err)
		}
	}

	if err := g.createKeysDirectory(); err != nil {
		return fmt.Errorf("failed to create keys directory: %w", err)
	}

	if err := g.createRequiredDirectories(cfg); err != nil {
		return fmt.Errorf("failed to create required directories: %w", err)
	}

	return nil
}

func (g *GeneratorService) generateGoAccessConfig() error {
	goAccessConfig := `time-format %T
date-format %d/%b/%Y
log_format %h - %^ [%d:%t %^]  %s "%r" %b "%R" "%u" "%^"
geoip-database /data/geoip/GeoLite2-City.mmdb`

	filePath := filepath.Join(g.outputDir, "goaccess.conf")
	if err := os.WriteFile(filePath, []byte(goAccessConfig), 0644); err != nil {
		return fmt.Errorf("failed to write goaccess.conf: %w", err)
	}

	return nil
}

func (g *GeneratorService) createKeysDirectory() error {
	keysDir := filepath.Join(g.outputDir, "keys")
	if err := os.MkdirAll(keysDir, 0755); err != nil {
		return fmt.Errorf("failed to create keys directory: %w", err)
	}

	srcKeysReadme := "./keys/README.md"
	if _, err := os.Stat(srcKeysReadme); err == nil {
		destKeysReadme := filepath.Join(keysDir, "README.md")
		if err := g.copyFile(srcKeysReadme, destKeysReadme); err != nil {
			return fmt.Errorf("failed to copy keys README.md: %w", err)
		}
	} else {
		keysReadmeContent := `# JWT Key Management

This directory contains JWT signing keys for the application.

## Setup Instructions

1. Generate Ed25519 key for JWT signing:
   ` + "```bash" + `
   openssl genpkey -algorithm Ed25519 -out jwt-ed25519.pem
   chmod 600 jwt-ed25519.pem
   ` + "```" + `

2. Or generate RSA key (alternative):
   ` + "```bash" + `
   openssl genrsa -out jwt-rsa.pem 3072
   chmod 600 jwt-rsa.pem
   ` + "```" + `

## Security Notes

- Never commit private keys to version control
- Set proper file permissions (600) for private keys
- Use different keys for different environments`

		readmePath := filepath.Join(keysDir, "README.md")
		if err := os.WriteFile(readmePath, []byte(keysReadmeContent), 0644); err != nil {
			return fmt.Errorf("failed to create keys README.md: %w", err)
		}
	}

	return nil
}

func (g *GeneratorService) createRequiredDirectories(cfg *model.SetupConfig) error {
	manageStaticDir := filepath.Join(g.outputDir, "manage_static")
	if err := os.MkdirAll(manageStaticDir, 0755); err != nil {
		return fmt.Errorf("failed to create manage_static directory: %w", err)
	}

	frontendDistDir := filepath.Join(g.outputDir, "frontend_dist")
	if err := os.MkdirAll(frontendDistDir, 0755); err != nil {
		return fmt.Errorf("failed to create frontend_dist directory: %w", err)
	}

	gitkeepPath := filepath.Join(manageStaticDir, ".gitkeep")
	if err := os.WriteFile(gitkeepPath, []byte{}, 0644); err != nil {
		return fmt.Errorf("failed to create .gitkeep: %w", err)
	}

	geoipDir := filepath.Join(g.outputDir, "geoip")
	if err := os.MkdirAll(geoipDir, 0755); err != nil {
		return fmt.Errorf("failed to create geoip directory: %w", err)
	}

	if cfg.GoAccess.Enabled && cfg.GoAccess.HasGeoFile && cfg.GoAccess.GeoTempPath != "" {
		tempGeoipFile := cfg.GoAccess.GeoTempPath
		destGeoipFile := filepath.Join(geoipDir, "GeoLite2-City.mmdb")

		if _, err := os.Stat(tempGeoipFile); err == nil {
			if err := g.copyFile(tempGeoipFile, destGeoipFile); err != nil {
				return fmt.Errorf("failed to copy GeoIP database from temp: %w", err)
			}

			if err := os.Remove(tempGeoipFile); err != nil {
				log.Printf("Warning: failed to remove temporary GeoIP file %s: %v", tempGeoipFile, err)
			} else {
				log.Printf("Temporary GeoIP file %s removed successfully", tempGeoipFile)
			}

			log.Printf("Copied GeoIP file from temp directory to output: %s", destGeoipFile)
		} else {
			return fmt.Errorf("GeoIP database file no longer available. The uploaded file may have been cleared. Please re-upload your GeoIP database file and try again")
		}
	}

	srcGeoipFile := "./geoip/Country.mmdb"
	destCountryFile := filepath.Join(geoipDir, "Country.mmdb")
	if _, err := os.Stat(srcGeoipFile); err == nil {
		if err := g.copyFile(srcGeoipFile, destCountryFile); err != nil {
			return fmt.Errorf("failed to copy traditional GeoIP database: %w", err)
		}
	}

	hasAnyGeoFile := false
	cityFile := filepath.Join(geoipDir, "GeoLite2-City.mmdb")
	countryFile := filepath.Join(geoipDir, "Country.mmdb")

	if _, err := os.Stat(cityFile); err == nil {
		hasAnyGeoFile = true
	}
	if _, err := os.Stat(countryFile); err == nil {
		hasAnyGeoFile = true
	}

	if !hasAnyGeoFile {
		gitkeepGeoipPath := filepath.Join(geoipDir, ".gitkeep")
		if err := os.WriteFile(gitkeepGeoipPath, []byte{}, 0644); err != nil {
			return fmt.Errorf("failed to create geoip .gitkeep: %w", err)
		}
	}

	return nil
}

func (g *GeneratorService) HandleJWTKeyFile(cfg *model.SetupConfig) error {
	keysDir := filepath.Join(g.outputDir, "keys")
	if err := os.MkdirAll(keysDir, 0755); err != nil {
		return fmt.Errorf("failed to create keys directory: %w", err)
	}

	if cfg.App.JWTKeyFromFile && cfg.App.JWTKeyFilePath != "" {
		log.Printf("Using custom JWT key file path: %s", cfg.App.JWTKeyFilePath)
		return nil
	}

	destPath := filepath.Join(keysDir, "jwt-private.pem")

	jwtKeyPEM, err := g.GenerateJWTKey()
	if err != nil {
		return fmt.Errorf("failed to generate JWT key: %w", err)
	}

	if err := os.WriteFile(destPath, jwtKeyPEM, 0600); err != nil {
		return fmt.Errorf("failed to write JWT key file: %w", err)
	}

	log.Printf("JWT key file automatically generated: %s", destPath)

	return nil
}

// SaveSetupConfiguration saves the complete setup configuration to .baklab-setup directory
func (g *GeneratorService) SaveSetupConfiguration(cfg *model.SetupConfig) error {
	// Create .baklab-setup directory
	setupDir := filepath.Join(g.outputDir, ".baklab-setup")
	if err := os.MkdirAll(setupDir, 0755); err != nil {
		return fmt.Errorf("failed to create .baklab-setup directory: %w", err)
	}

	// Create a sanitized copy for saving
	sanitizedCfg := g.sanitizeConfigForSaving(*cfg)

	// Save sanitized configuration
	configPath := filepath.Join(setupDir, "config.json")
	configData, err := json.MarshalIndent(sanitizedCfg, "", "  ")
	if err != nil {
		return fmt.Errorf("failed to marshal configuration: %w", err)
	}

	if err := os.WriteFile(configPath, configData, 0644); err != nil {
		return fmt.Errorf("failed to write config.json: %w", err)
	}

	// Save simple readme
	readmeContent := fmt.Sprintf(`BakLab Setup Configuration - Generated: %s

config.json: Setup configuration for revision and redeployment
SECURITY: Passwords and secrets have been removed for safety
Use this file with BakLab setup tool to modify existing deployment
Domain: %s
`,
		time.Now().Format("2006-01-02 15:04:05"),
		cfg.App.DomainName,
	)

	readmePath := filepath.Join(setupDir, "readme.txt")
	if err := os.WriteFile(readmePath, []byte(readmeContent), 0644); err != nil {
		return fmt.Errorf("failed to write readme.txt: %w", err)
	}

	log.Printf("Setup configuration saved to %s", setupDir)
	return nil
}

// sanitizeConfigForSaving creates a copy of config with sensitive information removed
func (g *GeneratorService) sanitizeConfigForSaving(cfg model.SetupConfig) model.SetupConfig {
	// Create a deep copy
	sanitized := cfg

	// Clear sensitive database passwords
	sanitized.Database.SuperPassword = ""
	sanitized.Database.AppPassword = ""

	// Clear sensitive Redis passwords
	sanitized.Redis.Password = ""
	sanitized.Redis.AdminPassword = ""

	// Clear SMTP password
	sanitized.SMTP.Password = ""

	// Clear admin user password
	sanitized.AdminUser.Password = ""

	// Clear OAuth client secrets
	sanitized.OAuth.GoogleSecret = ""
	sanitized.OAuth.GithubSecret = ""
	sanitized.App.OAuth.GoogleSecret = ""
	sanitized.App.OAuth.GithubSecret = ""

	// Clear Cloudflare secret
	sanitized.App.CloudflareSecret = ""

	// Clear temporary file paths that may contain sensitive data
	sanitized.GoAccess.GeoTempPath = ""
	sanitized.App.JWTKeyTempPath = ""

	// Add security notice to revision mode
	sanitized.RevisionMode.ModifiedSteps = append(sanitized.RevisionMode.ModifiedSteps,
		"SECURITY_NOTICE: Passwords and secrets removed for safety")

	return sanitized
}
